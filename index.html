<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Blogs of Zhaocheng">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blogs of Zhaocheng">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blogs of Zhaocheng">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Blogs of Zhaocheng</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blogs of Zhaocheng</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/06/opencv车辆识别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaocheng Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs of Zhaocheng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/06/opencv车辆识别/" itemprop="url">opencv车辆识别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-06T08:26:57+08:00">
                2018-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近要做交通管理和控制课程的实验，提到采集数据时老师说可以用多种方法来实现，因此想到自己编写一个车辆识别的程序。第一个想到的是循环神经网络，但是因为自己在机器学习方面造诣还是很浅的，因此选择了比较传统，也是相关论坛比较多的opencv进行实现，这里选用的级联分类器训练(Cascade Classifier)，一路上很多网上的大神的博客给了很详细的指导，记录下来，希望自己以后可以用到。</p>
<p><strong>参考文献：</strong></p>
<p>haar特征识别算法原理：<a href="https://blog.csdn.net/jing_xin/article/details/17383161" target="_blank" rel="noopener">https://blog.csdn.net/jing_xin/article/details/17383161</a></p>
<p>博主提到了很多有用的资源：<a href="https://blog.csdn.net/u014696921/article/details/69935802" target="_blank" rel="noopener">https://blog.csdn.net/u014696921/article/details/69935802</a></p>
<p>opencv关于Cascade Training的文档：<a href="https://docs.opencv.org/2.4/doc/user_guide/ug_traincascade.html" target="_blank" rel="noopener">https://docs.opencv.org/2.4/doc/user_guide/ug_traincascade.html</a></p>
<p>opencv关于Cascade detect的文档：<a href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html?highlight=haar" target="_blank" rel="noopener">https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html?highlight=haar</a></p>
<p>博主提供了详细的实现过程：<a href="https://blog.csdn.net/zhuangxiaobin/article/details/25476833" target="_blank" rel="noopener">https://blog.csdn.net/zhuangxiaobin/article/details/25476833</a></p>
<p><strong>使用资源：</strong></p>
<p>opencv软件，cv2模块(在python中使用opencv)，python，正负车辆样品集</p>
<h2 id="1-搭建需要在python中使用opencv的环境"><a href="#1-搭建需要在python中使用opencv的环境" class="headerlink" title="1. 搭建需要在python中使用opencv的环境"></a>1. 搭建需要在python中使用opencv的环境</h2><p>本次项目不仅需要在python中设置opencv环境，还需要下载opencv的软件到计算机上。因为cv2模块仅仅提供了一些简单的接口，不能够用来创建分类文件xml文件。具体的内容会在后面提到，因此需要下面两个步骤：</p>
<ul>
<li>step1： 安装opencv-python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<ul>
<li>step2：到官网下载opencv，并记住下载后存储的地址。</li>
</ul>
<p>我的存储路径为<code>D:\Program Files (x86)</code>随后打开路径<code>D:\Program Files (x86)\opencv\build\x64\vc14\bin</code>，可以看到后面我们需要用到的两个exe文件<code>opencv_createsamples.exe</code>，<code>opencv_traincascade.exe</code>分别用来创建正样品集和训练联机分类器，在bin文件中意味着它可以直接被cmd调用。</p>
<h2 id="2-创建正负训练样本集"><a href="#2-创建正负训练样本集" class="headerlink" title="2. 创建正负训练样本集"></a>2. 创建正负训练样本集</h2><h3 id="2-1-创建正样本集"><a href="#2-1-创建正样本集" class="headerlink" title="2.1 创建正样本集"></a>2.1 创建正样本集</h3><p><strong>step1：准备数据集</strong></p>
<p>正样本集可以从网上下载训练的开源数据，数据在前面的参考博客中已经给出，也可以在网上查找一些网友自己做的数据集，正样品应当尽量只包含目标物体，尽量减少周围环境的介入。如果非要自己做的话，可以使用<code>objectmarker.exe</code>一个网上可以下载到的程序，可以在我的github网页上下载，不过相对比较麻烦。注意无论是从网上找到的数据集还是自己创建都尽量创建比例较为近似的图片，以便后面做归一化处理。以下是我选择的数据集：</p>
<p>注：在未处理以前有很多jpg文件，转化方法可以在该文件夹中创建一个.txt文件，其中输入<code>ren *.jpg *.bmp</code>后将后缀改为.bat(cmd的代码)，点击运行即可将文件夹中的每一个图片修改为.bmp格式。</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180608210759.png" alt="TIM截图20180608210759"></p>
<p><strong>step2：归一化处理</strong></p>
<p>随后我们需要对数据集中的数据做归一化处理，并且转化为灰度图片，该过程的python代码如下。因为将图片缩小有利于训练的效率，因此将宽和高均设置为25(opencv本身的数据集为24)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> os.path  </span><br><span class="line"><span class="keyword">import</span> glob  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertjpg</span><span class="params">(jpgfile,outdir,width=<span class="number">25</span>,height=<span class="number">25</span>)</span>:</span>  </span><br><span class="line">    print(jpgfile)</span><br><span class="line">    img=Image.open(jpgfile)</span><br><span class="line">    print(img)</span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        new_imgt = img.resize((width, height), Image.BILINEAR)</span><br><span class="line">        new_img = new_imgt.convert(<span class="string">'L'</span>)</span><br><span class="line">        print(new_img)</span><br><span class="line">        new_img.save(os.path.join(outdir, os.path.basename(jpgfile)))  </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">        print(e)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> jpgfile <span class="keyword">in</span> glob.glob(<span class="string">"D:/anaconda/gpsdata/*.bmp"</span>):  </span><br><span class="line">    convertjpg(jpgfile,<span class="string">"D:/anaconda/gpsdata1"</span>)</span><br></pre></td></tr></table></figure>
<p>归一化后的图片如下图所示：</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180608210816.png" alt="TIM截图20180608210816"></p>
<p><strong>step3：创建正样品描述vec文件</strong></p>
<p>我的归一化正样品的储存目录为<code>D:/anaconda/gpsdata1</code>因此在该文件夹下，<code>shift+右键</code>-&gt;<code>在此处打开命令窗口</code>打开cmd后输入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\anaconda\gpsdata1</span><br><span class="line">dir/s/b&gt;pos.txt</span><br></pre></td></tr></table></figure>
<p>即可在文件夹中得到一个pos.txt样本描述文件，文件记录了目录中的每一个图片的目录和文件名。具体样式如下图所示，虽然这还不是我们想要的格式，注意查看最后一行是不是图片还是txt文件本身：</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180608212139.png" alt="TIM截图20180608212139"></p>
<p>这一步是比较特殊的，因为我的每一个图片大小相等且大小为25才可以这样做。对于一些图片大小非正方形或者大小大于30的慎用。随后我们将这个描述文件复制粘贴到word软件中，使用查找替换功能将每一行替换为如下图的格式，格式从左到右分别描述了表中的属性(此处宽和高均为30其实没有必要，因为图片大小只有25…)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">图片相对路径</th>
<th style="text-align:center">兴趣矩形个数</th>
<th style="text-align:center">矩形左坐标</th>
<th style="text-align:center">矩形上坐标</th>
<th style="text-align:center">矩形宽度</th>
<th style="text-align:center">矩形高度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">gpsdata1\1039284.bmp</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">30</td>
<td style="text-align:center">30</td>
</tr>
</tbody>
</table>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180608212706.png" alt="TIM截图20180608212706"></p>
<h3 id="2-2-创建负样本集"><a href="#2-2-创建负样本集" class="headerlink" title="2.2 创建负样本集"></a>2.2 创建负样本集</h3><p>创建负样本比创建正样本简单很多，但需要比正样本大很多的样本量，因为在视频/图片当中不是目标物体的实际上是比较多的。负样品的内容应该多是道路上非车辆的物体，例如行人、建筑物等，火星、外太空啥的就算了。以下是我从网上下载的负样品：</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180609080723.png" alt="TIM截图20180609080723"></p>
<p>通过和正样本相同的处理方法，首先将图片转化为bmp文件，在缩小并转化为黑白的图片(此处应按比例转化，并且保证比处理后的大小比正样品大即可)：</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180609081342.png" alt="TIM截图20180609081342"></p>
<p>同样创建一个描述文件(方法和创建正样品是step 3第一步的方法一样)，创建后如图：</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180609081806.png" alt="TIM截图20180609081806"></p>
<h3 id="2-3-生成vec文件"><a href="#2-3-生成vec文件" class="headerlink" title="2.3 生成vec文件"></a>2.3 生成vec文件</h3><p>vec文件是opencv中用来描述图片的矩阵文件，就是将可视的图片转化为矩阵存储。下面分步骤完成。</p>
<ul>
<li><strong>step1 创建需要的环境</strong></li>
</ul>
<p>首先将正负样本及其描述文件，最开始文中提到的<code>opencv_createsamples.exe</code>文件放在一个文件夹下(很重要！)，如下图所示(忽视那个bat文件，下文会讲到)：</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180610171937.png" alt="TIM截图20180610171937"></p>
<p>修改正负样本描述文件的相对路径，使其指向各自的文件夹，这一步可以在很久以前完成…但自己走了一波弯路…还是在word中使用查找替换。替换后的文件如图所示：</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180610172713.png" alt="TIM截图20180610172713"></p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180610172832.png" alt="TIM截图20180610172832"></p>
<ul>
<li><strong>step2 编写创建vec的bat指令</strong></li>
</ul>
<p>这就是我们上文提到的bat文件了，在该文件夹下新建一个txt文件，写下如下指令，不同的参数可以自己调整：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-info 描述文件 -vec vec文件名 -num正样本数量 -h-w分别为样本高宽</span></span><br><span class="line">opencv_createsamples.exe -info pos.txt -vec pos.vec -num 762 -h 24 -w 24</span><br></pre></td></tr></table></figure>
<p>修改后缀为.bat并且运行就得到一个vec文件。</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180610173859.png" alt="TIM截图20180610173859"></p>
<p>至此，准备工作结束，下面就是训练样品了。</p>
<h2 id="3-使用adaboost算法训练数据"><a href="#3-使用adaboost算法训练数据" class="headerlink" title="3. 使用adaboost算法训练数据"></a>3. 使用adaboost算法训练数据</h2><p>首先我们在现在的文件夹中新建一个文件夹，命名为cascade_data，其中存储训练后的XML文件数据。然后将文中开头提到的<code>opencv_traincascade.exe</code>放入我们的现在的文件夹。再编写一个我们训练模型用的classify.bat文件，文件的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bg背景描述文件，</span></span><br><span class="line">opencv_traincascade.exe -data data -vec pos.vec -<span class="built_in">bg</span> neg.txt -numPos 762 -numNeg 7708 -numStages 18 -w 24 -h 24 -minHitRate 0.9999 -maxFalseAlarmRate 0.5 -mode ALL</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>文件夹中的文件有以下几个：</p>
<p><img src="/2018/08/06/opencv车辆识别/TIM截图20180610183242.png" alt="TIM截图20180610183242"></p>
<p>点击classify.bat文件就可以开始训练了，我从下午6.30开始训练，训练到</p>
<h2 id="4-使用cv2做视频处理"><a href="#4-使用cv2做视频处理" class="headerlink" title="4.使用cv2做视频处理"></a>4.使用cv2做视频处理</h2><ul>
<li><strong>step1 使用XML文件对cv2的联机分类器进行标定</strong></li>
</ul>
<p>这一部分的语法可以参考上面的关于cascade_detection的参考文献，其中有较为详细的语法。我们需要拿我们在上一步训练得到的XML文件首先对识别器进行标定。语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car_cascade = cv2.CascadeClassifier(<span class="string">'haarcascade_frontalface_default.xml'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>step2 创建截取和写入视频的对象</strong></li>
</ul>
<p>首先我们知道视频是由一帧帧的图片组成的，衡量的单位为FPS(Frame Per Second)，我们首先导入cv2并且创建视频截取的对象。它的参数可以是设备索引，也可以是要读取的视频文件的名称。</p>
<p>在大多数情况下，只有一台摄像机连接到系统。 所以，我们所做的只是传递’0’，OpenCV使用连接到计算机的唯一相机。 当多台摄像机连接到电脑时，我们可以通过’1’来选择第二台摄像机，通过’2’来选择第三台摄像机，等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个视频截取对象和一个视频存储对象</span></span><br><span class="line"><span class="comment"># 如果视频是通过计算机的摄像头识别的，则传入0，这里传入我们录制的车辆视频</span></span><br><span class="line"></span><br><span class="line">fps = <span class="number">24</span>   <span class="comment">#视频帧率</span></span><br><span class="line">fourcc = cv2.cv.CV_FOURCC(<span class="string">'M'</span>,<span class="string">'J'</span>,<span class="string">'P'</span>,<span class="string">'G'</span>) </span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">'chaplin.mp4'</span>)</span><br><span class="line">videoWriter = cv2.VideoWriter(<span class="string">'D:/testResults/match/flower2.avi'</span>, fourcc, fps, (<span class="number">1360</span>,<span class="number">480</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>step3 逐帧处理并写入视频</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> moviepy.editor <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment">#from cv2 import cv</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">'E:/学海无涯/20180613_IMG_0627 (3).MOV'</span></span><br><span class="line">fps = <span class="number">24</span>   <span class="comment">#视频帧率</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'XVID'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#clip = VideoFileClip(filename).subclip(242,291)</span></span><br><span class="line"><span class="comment">#clip.write_videofile("E:/学海无涯/rawvideo.mp4")</span></span><br><span class="line"></span><br><span class="line">car_cascade = cv2.CascadeClassifier(<span class="string">'C:/Users/Administrator/Desktop/lll/haarcascade_eye.xml'</span>)</span><br><span class="line">car_cascade.load(<span class="string">'C:/Users/Administrator/Desktop/lll/haarcascade_eye.xml'</span>)</span><br><span class="line">VideoCap = cv2.VideoCapture(<span class="string">"E:/学海无涯/rawvideo.mp4"</span>)</span><br><span class="line">videoWriter = cv2.VideoWriter(<span class="string">'E:/学海无涯/processedvideo.mp4'</span>, fourcc, fps, (<span class="number">1360</span>,<span class="number">480</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(VideoCap.isOpened()):</span><br><span class="line">  ret, frame = VideoCap.read() <span class="comment">#逐帧获取视频，frame是图片</span></span><br><span class="line">  <span class="keyword">if</span> ret == <span class="keyword">True</span>: <span class="comment">#处理并显示这一帧的图片</span></span><br><span class="line">      gray_img = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) <span class="comment">#转化为灰度图</span></span><br><span class="line">      cars = car_cascade.detectMultiScale(gray_img, <span class="number">1.3</span>, <span class="number">5</span>) <span class="comment">#车辆检测，返回(x,y,w,h)</span></span><br><span class="line">      <span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> cars: <span class="comment">#对每一个兴趣区画框</span></span><br><span class="line">        	cv2.rectangle(frame,(x,y),(x+w,y+h),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">      cv2.imshow(<span class="string">'Frame'</span>,frame) <span class="comment">#显示图片</span></span><br><span class="line">      videoWriter.write(frame)</span><br><span class="line">      <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>): <span class="comment">#按Q停止</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">else</span>: <span class="comment">#没有帧后显示循环</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#处理完后释放所有的对象</span></span><br><span class="line">VideoCap.release()</span><br><span class="line">videoWriter.release()</span><br><span class="line"><span class="comment">#关闭所有帧</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>在做完了这一波之后越来越觉得掌握算法本身比掌握如何使用算法更加的重要，相比而言现在的东西还是一个半成品，代码什么的后面还需要改进。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/06/预习作业1-大数据量查找重复数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaocheng Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs of Zhaocheng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/06/预习作业1-大数据量查找重复数据/" itemprop="url">预习作业1--大数据量查找重复数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-06T08:02:04+08:00">
                2018-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本次的作业是在大数据实习前的三个预习作业第一项，其问题描述如下：</p>
<p>有两个文件分别存储着升序排列的整形数据(没有重复的数据),写一个程序将这两个文件的整形数据的交集找出来,要求程序运行速度最优。</p>
<p>本次编程使用C++完成。</p>
<p><strong>参考文献</strong></p>
<p>二叉树算法：<a href="http://blog.jobbole.com/104106/" target="_blank" rel="noopener">http://blog.jobbole.com/104106/</a></p>
<p>gdb使用教程：<a href="http://witmax.cn/gdb-usage.html" target="_blank" rel="noopener">http://witmax.cn/gdb-usage.html</a></p>
<h2 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h2><p><strong>时间复杂度</strong>：</p>
<p>时间复杂度是指执行算法所需要的计算工作量，简单来说，时间复杂度指的是语句执行次数。</p>
<p><strong>时间复杂度计算方法</strong>：</p>
<ol>
<li>用常数1代替运行时间中的所有加法常数 </li>
<li>修改后的运行次数函数中，只保留最高阶项 </li>
<li>去除最高阶项的系数</li>
</ol>
<h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2.环境配置"></a>2.环境配置</h2><p>从windows转换为linux之后各种不适应，现在刚刚反应过来，linux系统并不存在windows系统中各种友好的图像化软件，例如<code>Visual Studio 2008</code> 这种鬼，它已经彻底颠覆了我对于计算机的思维…</p>
<p><strong>C++在linux系统中编译</strong></p>
<p>在linux中首先要将C++文件<code>.cpp</code> 使用<code>g++</code> 进行编译，什么是编译呢，通过查询，就是将高级语言转化为计算机可识别，可运行的二进制文件。其实我们可以看到在linux系统当中，所有的指令，例如<code>ls</code> ,<code>mv</code> 都是通过编译后将高级语言转化为的简单指令，因为后的文件就可以直接在shell中输入运行了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>
<p>其中 -g是为了能够显示变量名和函数名，不然显示是一段二进制地址。</p>
<p><strong>C++在linux系统中调试</strong></p>
<p>在编译之后我们要进行代码的调试，在linux系统当中使用<code>GDB</code>来对已经编译好的代码进行调试，在bash</p>
<p>中输入<code>GDB</code>即可打开相应界面和指令。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>file helloworld</td>
<td>打开已编译完的helloworld可执行文件</td>
</tr>
<tr>
<td>l</td>
<td>查看源代码</td>
</tr>
<tr>
<td>b func</td>
<td>在某函数处设置断点</td>
</tr>
<tr>
<td>b 16</td>
<td>在第16行插入断点</td>
</tr>
<tr>
<td>n</td>
<td>从断点下一步</td>
</tr>
<tr>
<td>p i</td>
<td>打印变量i的值</td>
</tr>
<tr>
<td>c</td>
<td>继续执行下面的</td>
</tr>
<tr>
<td>delete 16</td>
<td>删除断点16</td>
</tr>
</tbody>
</table>
<h2 id="3-实现方法"><a href="#3-实现方法" class="headerlink" title="3.实现方法"></a>3.实现方法</h2><p><strong>基本思路</strong></p>
<p>step1,  先在文档1和文档2中读取一个基本数据</p>
<p>step2,  将这两个数据进行对比大小</p>
<p>step3, 若两个数据大小相同，存入output.txt文档当中</p>
<p>​            若文档1中数据大于文档2中数据，文档2重新读入一个数据(因为这样数据可以数据2变大)</p>
<p>​            若文档2中数据大于文档2中数据，文档1重新读入一个数据(因为这样数据可以数据1变大)</p>
<p>step4, 销毁fin1,fin2,fout对象，释放内存</p>
<p><strong>实现C++代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> line1;</span><br><span class="line">    <span class="built_in">string</span> line2;</span><br><span class="line">    <span class="built_in">string</span> line3;</span><br><span class="line">    <span class="keyword">int</span> data1;</span><br><span class="line">    <span class="keyword">int</span> data2;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin1</span><span class="params">(<span class="string">"/media/vincent/新加卷/data/1_1.txt"</span>)</span></span>; <span class="comment">//点1</span></span><br><span class="line">    <span class="function">ifstream <span class="title">fin2</span><span class="params">(<span class="string">"/media/vincent/新加卷/data/1_2.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"/media/vincent/新加卷/data/output.txt"</span>)</span></span>;</span><br><span class="line">    fin1 &gt;&gt; line1; <span class="comment">//点2</span></span><br><span class="line">    fin2 &gt;&gt; line2;</span><br><span class="line">    <span class="keyword">while</span> (!fin1.eof() &amp; !fin2.eof()) </span><br><span class="line">    &#123;</span><br><span class="line">        data1 = atoi(line1.c_str()); <span class="comment">//点2</span></span><br><span class="line">        data2 = atoi(line2.c_str());</span><br><span class="line">        <span class="keyword">if</span> (data1 == data2)</span><br><span class="line">        &#123;</span><br><span class="line">            fout &lt;&lt; line1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            fin1 &gt;&gt; line1;</span><br><span class="line">            fin2 &gt;&gt; line2;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"line1"</span> &lt;&lt; line1 &lt;&lt; <span class="string">"line2"</span> &lt;&lt; line2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data1 &lt; data2)</span><br><span class="line">        &#123;</span><br><span class="line">            fin1 &gt;&gt; line1;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"line1"</span> &lt;&lt; line1 &lt;&lt; <span class="string">"line2"</span> &lt;&lt; line2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            fin2 &gt;&gt; line2;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"line1"</span> &lt;&lt; line1 &lt;&lt; <span class="string">"line2"</span> &lt;&lt; line2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    fin1.close(); <span class="comment">//点4</span></span><br><span class="line">    fin2.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++相关示意</strong></p>
<p>点1：使用<code>ifstream</code>和<code>ofstream</code>定义输入输出文档</p>
<p>点2：将字符串型数据转化为整形数据，便于后面对比大小</p>
<p>点3：销毁对象，释放内存</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/06/预习作业2-快速排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaocheng Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs of Zhaocheng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/06/预习作业2-快速排序算法/" itemprop="url">预习作业2--快速排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-06T08:01:14+08:00">
                2018-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本次作业是暑假实习项目作业的第二项，问题描述如下：</p>
<p>有一个文件存储的是整形数据(每一行代表一个整形值),写一个程序将最小top-k 的整形数据找出来,这里我们假定 k=10,要求程序运行速度最优。</p>
<p>这是一个典型的<code>top-k</code>问题，常用的算法有<code>quickselect</code>和<code>minheap</code>等。本次决定使用快速排序算法完成，编程使用C++完成。</p>
<p><strong>攻克难点</strong></p>
<ul>
<li>处理7千万条数据</li>
<li>使用完全不熟练的C++编程</li>
<li>快速选择算法的理解和实现</li>
</ul>
<p><strong>参考文献</strong></p>
<p>快速排序原理：<a href="https://blog.csdn.net/sinat_20177327/article/details/76560079" target="_blank" rel="noopener">https://blog.csdn.net/sinat_20177327/article/details/76560079</a></p>
<p>模板的相关概念：<a href="https://blog.csdn.net/zqixiao_09/article/details/51474589" target="_blank" rel="noopener">https://blog.csdn.net/zqixiao_09/article/details/51474589</a></p>
<p>快速选择C++的实现：<a href="https://www.cnblogs.com/whensean/p/selection.html" target="_blank" rel="noopener">https://www.cnblogs.com/whensean/p/selection.html</a></p>
<p>一些海量数据处理的算法：<a href="https://blog.csdn.net/hguisu/article/details/7856239" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/7856239</a></p>
<h2 id="一、所需C-技术"><a href="#一、所需C-技术" class="headerlink" title="一、所需C++技术"></a>一、所需C++技术</h2><p>在C++编程和逻辑实现中遇到了一下的技术问题：</p>
<h3 id="1-1-使用函数返回数组"><a href="#1-1-使用函数返回数组" class="headerlink" title="1.1 使用函数返回数组"></a>1.1 使用函数返回数组</h3><p>在后面的编程中需要用到一个返回排序后数组的函数，但返回数组的函数并不像python那么简单，需要使用指针函数和指针数组的技术，会在下面进行讨论。</p>
<h4 id="1-1-1-指针技术"><a href="#1-1-1-指针技术" class="headerlink" title="1.1.1 指针技术"></a>1.1.1 指针技术</h4><p>指针在本质上是一个指向变量所存储地址的东西，下面是它的使用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p <span class="comment">//一个指向int类型地址的指针p</span></span><br></pre></td></tr></table></figure>
<p>有时我们也需要获取一个变量的地址，这是使用取址符<code>&amp;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; <span class="keyword">int</span> a; p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>声明<strong>指针数组</strong>，在我们声明了一个数组之后<code>a[10]</code>之后，<code>*a[0]</code>就是数组的第一位地址，而<code>*a[0] + 10</code>就是末尾地址再加一。下面是输出数组的一个例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = a; p &lt;&amp; a + <span class="number">10</span>; p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(p = *a[<span class="number">0</span>]; p &lt; *a[<span class="number">0</span>] + <span class="number">10</span>; p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, *p);</span><br></pre></td></tr></table></figure>
<p>以及可以声明<strong>指针函数</strong>和<strong>返回指针的函数</strong>，使用以下格式（*要在括号外，被认为返回 <code>int*</code> 型）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*Psum)(<span class="keyword">int</span>*, <span class="keyword">int</span>); <span class="comment">//这是一个指针函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">Psum</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>; <span class="comment">//这是一个返回指针的函数</span></span><br></pre></td></tr></table></figure>
<p>在函数想要返回一个数组时，采用的是一个指针函数，基本格式如<code>int *copy()</code></p>
<h4 id="1-1-2-变量作用域"><a href="#1-1-2-变量作用域" class="headerlink" title="1.1.2 变量作用域"></a>1.1.2 变量作用域</h4><table>
<thead>
<tr>
<th style="text-align:center">变量类型</th>
<th style="text-align:center">储存区域</th>
<th style="text-align:center">作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">静态变量</td>
<td style="text-align:center">数据区</td>
<td style="text-align:center">独立于对象，存在于全局</td>
</tr>
<tr>
<td style="text-align:center">局部变量</td>
<td style="text-align:center">栈区(stack)</td>
<td style="text-align:center">函数内部，函数消失后自动消失</td>
</tr>
<tr>
<td style="text-align:center">动态变量</td>
<td style="text-align:center">堆区(heap)</td>
<td style="text-align:center">经常创建的对象、动态的申请的临时空间(程序员决定)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">代码区</td>
<td style="text-align:center">代码存放的位置</td>
</tr>
</tbody>
</table>
<p>这告诉我们，在一个数组返回一个自己的指针的同时，这个代码内部的各个变量都已经销毁了，所以必须使用其他的方法返回一个数组。</p>
<h4 id="1-1-3-返回数组的函数编写"><a href="#1-1-3-返回数组的函数编写" class="headerlink" title="1.1.3 返回数组的函数编写"></a>1.1.3 返回数组的函数编写</h4><p>通过上面的分析，要想能够接收到返回来的数组，并不能将一整个数组<code>return</code>回来。而应该定义一个返回指针的函数，最后返回数组的第一个元素的指针，并且使用一个指针进行接收。代码如下：</p>
<p>step1: 定义一个返回指针的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">copy</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> <span class="comment">//注意定义函数格式和传入数组格式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        a[i] = <span class="built_in">array</span>[i];</span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">//返回一个头地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>step2: 在<code>main</code>函数中使用，赋给<code>p</code>的是一个数字的头地址(指针)<code>a</code>，试想<code>a</code>作为一个地址，可以使用<code>a[0]</code>等调用函数中的值，那么我们也可以使用<code>p[0]</code>做相应的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> a2[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> a1[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p = copy(a1, a2, size); <span class="comment">//注意此处调用copy函数，传入的是a1和a2，并且赋值给指针p</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; p[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//注意此处p[]亦可作为数组使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-理解Template模板"><a href="#1-2-理解Template模板" class="headerlink" title="1.2 理解Template模板"></a>1.2 理解Template模板</h3><p>这里利用模板有两个目的：</p>
<ul>
<li>如果我们使用STL的<code>vector</code>容器，它的本质上是由<code>template</code>编写而成的。</li>
<li>如果我们自己编写快排算法，可以使用<code>template</code>编写获取数组长度的函数，从而判断是否需要递归。</li>
</ul>
<h4 id="1-2-1-什么是模板"><a href="#1-2-1-什么是模板" class="headerlink" title="1.2.1 什么是模板"></a>1.2.1 什么是模板</h4><p>模板可以定义一个我们需要的通用函数，这些函数能够接受任意数据类型的参数，返回任意类型的值，而不需要对函数做重载，其语法可以是下面的两种形式(两种形式等价)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">general_name</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;typename general_name&gt;</span></span><br></pre></td></tr></table></figure>
<p>在通过模板定义一个多个数据类型都通用的函数时，遵循以下的语法规则(T就是上文当中的<code>general_name</code>，是一种规定俗成的写法)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">getmax</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a &gt; b ? a :b;&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的额理解方式是，这个时候的<code>T</code>可以为任何一种数据类型，比如说<code>int</code>在声明为<code>int</code>后，所有的<code>T</code>都被替换为<code>int</code>，例如我们想要对<code>int</code>型进行比较时可以使用下面这种语法，在参数类型相同时函数后面的<code>int</code>可以省略，但不同时不能够省略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">getmax&lt;<span class="keyword">int</span>&gt;(i, j)</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-sizeof-函数"><a href="#1-2-2-sizeof-函数" class="headerlink" title="1.2.2 sizeof()函数"></a>1.2.2 sizeof()函数</h4><p><code>sizeof</code>函数是用来计算一个对象的内存大小的函数，我们将它应用于计算一个数组内数字的大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h4 id="1-1-3-返回数组大小的函数编写"><a href="#1-1-3-返回数组大小的函数编写" class="headerlink" title="1.1.3 返回数组大小的函数编写"></a>1.1.3 返回数组大小的函数编写</h4><p>在这一部分我们就需要结合<code>sizeof</code>和<code>template</code>编写一个可以返回数组长度的函数，为什么需要用到<code>template</code>呢，在我们声明数组时也有<code>int arr[10]</code>或<code>float arr[10]</code>这种差别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">get_arr_length</span>(<span class="title">T</span> &amp; <span class="title">array</span>) //输入<span class="title">array</span>的头地址</span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-使用STL的vector容器"><a href="#1-3-使用STL的vector容器" class="headerlink" title="1.3 使用STL的vector容器"></a>1.3 使用STL的vector容器</h3><p>vector是C++中的一种数据结构，确切的说是一个类。它相当于一个动态的数组，当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的。</p>
<h4 id="1-3-1-vector如何声明和定义"><a href="#1-3-1-vector如何声明和定义" class="headerlink" title="1.3.1 vector如何声明和定义"></a>1.3.1 vector如何声明和定义</h4><p>首先我们需要在最上面对<code>vector</code>类进行<code>#include&lt;vector&gt;</code>，也需要加上<code>using namespace std</code>，随后我们需要对变量进行相应的定义，这里我们从一位数组向多维数组迈进：</p>
<ul>
<li>定义一维数组:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a; <span class="comment">//等于声明了一个int数组a[],大小没有指定,可以动态的向里面添加删除</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义二位数组:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span> *&gt; a; <span class="comment">//一个数组的名字其实代表的是它的首地址,这样我们相当于申请了一个数组的首地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义三维数组:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>**&gt; a; <span class="comment">//定义了一个二维平面的首地址...</span></span><br></pre></td></tr></table></figure>
<p>剩下的就是依次类推了。</p>
<h4 id="1-3-2-vector的使用"><a href="#1-3-2-vector的使用" class="headerlink" title="1.3.2 vector的使用"></a>1.3.2 vector的使用</h4><p>这里对使用做了以下的总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法(method)</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c.push_back(elem)</td>
<td style="text-align:center">在数组的最后添加一个数据</td>
</tr>
<tr>
<td style="text-align:center">c.pop_back(elem)</td>
<td style="text-align:center">去掉数组的最后一个数据</td>
</tr>
<tr>
<td style="text-align:center">at</td>
<td style="text-align:center">得到编号位置的数据</td>
</tr>
<tr>
<td style="text-align:center">begin</td>
<td style="text-align:center">得到数组头的指针</td>
</tr>
<tr>
<td style="text-align:center">end</td>
<td style="text-align:center">得到数组的最后一个单元+1的指针</td>
</tr>
<tr>
<td style="text-align:center">front</td>
<td style="text-align:center">得到数组头的引用</td>
</tr>
<tr>
<td style="text-align:center">back</td>
<td style="text-align:center">得到数组的最后一个单元的引用</td>
</tr>
<tr>
<td style="text-align:center">max_size</td>
<td style="text-align:center">得到vector最大可以是多大</td>
</tr>
<tr>
<td style="text-align:center">capacity</td>
<td style="text-align:center">当前vector分配的大小</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">当前使用数据的大小</td>
</tr>
<tr>
<td style="text-align:center">c.resize(num)</td>
<td style="text-align:center">改变当前使用数据的大小，如果它比当前使用的大，或者填充默认值</td>
</tr>
<tr>
<td style="text-align:center">reserve</td>
<td style="text-align:center">改变当前vecotr所分配空间的大小</td>
</tr>
<tr>
<td style="text-align:center">c.erase(pos) / c.erase(begin,end)</td>
<td style="text-align:center">删除指针指向的数据项</td>
</tr>
<tr>
<td style="text-align:center">clear</td>
<td style="text-align:center">清空当前的vector</td>
</tr>
<tr>
<td style="text-align:center">rbegin</td>
<td style="text-align:center">将vector反转后的开始指针返回(其实就是原来的end-1)</td>
</tr>
<tr>
<td style="text-align:center">rend</td>
<td style="text-align:center">将vector反转构的结束指针返回(其实就是原来的begin-1)</td>
</tr>
<tr>
<td style="text-align:center">empty</td>
<td style="text-align:center">判断vector是否为空</td>
</tr>
<tr>
<td style="text-align:center">swap</td>
<td style="text-align:center">与另一个vector交换数据</td>
</tr>
<tr>
<td style="text-align:center">c.insert(pos,elem)</td>
<td style="text-align:center">pos处插入elem</td>
</tr>
</tbody>
</table>
<h3 id="1-4-读取和处理较大的数据"><a href="#1-4-读取和处理较大的数据" class="headerlink" title="1.4 读取和处理较大的数据"></a>1.4 读取和处理较大的数据</h3><p>在本次作业刚开始便遇到一个很棘手的问题，在<code>linux</code>系统中很难定义一个单一的含有大于2千万个数字的数组，而我的数据量高达7千万，在经过查阅之后，发现了分治算法，但本问题还不是分治算法，因为面对问题是文件读不进来…需要将数组拆分很多次读取进来分别处理最终合成一个整体解决<code>top-k问题</code>，但做一下简单的了解。</p>
<h4 id="1-4-1-分治思想"><a href="#1-4-1-分治思想" class="headerlink" title="1.4.1 分治思想"></a>1.4.1 分治思想</h4><p>分治思想有三个步骤：</p>
<p>step1 分–将问题分解为规模更小的子问题。</p>
<p>step2 治–将这些规模更小的子问题逐个击破。</p>
<p>step3 合–将已解决的子问题合并，最终得出“母”问题的解。</p>
<p>但分治思想和本题不相符合的一点是，分治思想当中的每一个子问题都是相互独立的，但是我们要在一个巨大的无须数据集中选择前k个无论如何划分都是难以保证相互独立的。因此也便催生了下面的方法。</p>
<h4 id="1-4-2-本次处理方法"><a href="#1-4-2-本次处理方法" class="headerlink" title="1.4.2 本次处理方法"></a>1.4.2 本次处理方法</h4><p>step1 将7千多万条数据拆分为4分</p>
<p>step2 每次读取2千万条数据进行快选(quickselect)</p>
<p>step3 将每一组数选择出的前k大的数组合并到另一个<code>vector</code>中</p>
<p>step4 将这一层<code>vector</code>使用快选算法得到最终结果</p>
<h2 id="二、算法描述"><a href="#二、算法描述" class="headerlink" title="二、算法描述"></a>二、算法描述</h2><p>在网上并没有看到一个详细描述快选算法的博客，<code>Wiki</code>百科上也不是很能看懂，试着自己写一下。</p>
<h3 id="2-1-快排算法-快选算法的根基"><a href="#2-1-快排算法-快选算法的根基" class="headerlink" title="2.1 快排算法(快选算法的根基)"></a>2.1 快排算法(快选算法的根基)</h3><p>快选算法运用的根基便是分治思想(分治思想及其依赖于递归算法)，其实现的思想如下：</p>
<h4 id="2-1-1-算法例子及原理"><a href="#2-1-1-算法例子及原理" class="headerlink" title="2.1.1 算法例子及原理"></a>2.1.1 算法例子及原理</h4><p>问题：有这么一组数 6  8  4  2  7  1  9  3  5  0，对其从小到大排序。</p>
<p>step1 首先我们确定我们需要排序的这一组数字，我们要对他做升序排列：</p>
<p>​                     6 | 8 | 4 | 2 | 7 | 1 | 9 | 3 | 5 | 0</p>
<p>step2 选择一个枢纽值，并且确定两个分别指向头和尾的指针，两个指针分别命名为<code>low</code>和<code>high</code>。这然后我们用用<strong>加粗</strong>表示枢纽值，<code>代码框</code>表示两个指针。<strong><em>斜体加粗</em></strong>代表又是枢纽值又是一个指针，6是<strong><em>斜体加粗</em></strong>是因为我选择它作为枢纽值的同时，它是<code>low</code>指向的元素。</p>
<p>​                         <strong><em>6</em></strong> | 8 | 4 | 2 | 7 | 1 | 9 | 3 | 5 | <code>0</code></p>
<p>step3 做一次判断，记住升序排列时比6小的应该在6的左边，vice versa。</p>
<p>如果<code>high</code>指针指向的元素<strong>小于</strong>6，则它应保持不动，继续指向这个数值，就像现在它指向0，下次依然指向0(因为0就是要下次换到6左边的数啊，如果<code>high</code>指针不再指向0，去指向5，0就永远在6的右边了，我们也完不成升序排列了)。如果<code>high</code>指针指向的元素<strong>大于等于</strong>6，则<code>high</code>指针应不断向左移动，直到指向一个<strong>小于</strong>6的数字。</p>
<p>同理，如果<code>low</code>指向的元素<strong>大于</strong>6，则<code>low</code>指向的元素不变。而如果<code>low</code>指向的元素<strong>小于等于</strong>6，那么我们将<code>low</code>指针向左移动直到它指向一个<strong>大于</strong>6的数字。就像本次，<code>low</code>指针指向的是6，是等于6的，我们将它右移，发现8是<strong>大于</strong>6的，<code>low</code>便指向了8。</p>
<p>大家一定要记得先移动<code>high</code>指针！！！到step9 大家就明白了。</p>
<p>随后我们的数组就变成这样了：</p>
<p>​                     <strong>6</strong> | <code>8</code> | 4 | 2 | 7 | 1 | 9 | 3 | 5 | <code>0</code>                    </p>
<p>step 4 互换<code>low</code>和<code>high</code>指向的元素：</p>
<p>​                                         <strong>6</strong> | <code>0</code> | 4 | 2 | 7 | 1 | 9 | 3 | 5 | <code>8</code></p>
<p>step 5 此时<code>high</code>指向的元素为8，大于6，左移到一个小于6的数字，移动到5。<code>low</code>指向的元素为0，小于6，右移到一个大于6的数，移动到7。</p>
<p>​                                         <strong>6</strong> | 0 | 4 | 2 | <code>7</code> | 1 | 9 | 3 | <code>5</code> | 8</p>
<p>step 6 互换<code>low</code>和<code>high</code>指向的元素：</p>
<p>​                                         <strong>6</strong> | 0 | 4 | 2 | <code>5</code> | 1 | 9 | 3 | <code>7</code> | 8</p>
<p>step 7 此时<code>high</code>指向的元素为7，大于6，左移到一个小于6的数字，移动到3。<code>low</code>指向的元素为5，小于6，右移到一个大于6的数，移动到9。</p>
<p>​                                         <strong>6</strong> | 0 | 4 | 2 | 5 | 1 | <code>9</code> | <code>3</code> | 7 | 8</p>
<p>step 8 互换<code>low</code>和<code>high</code>指向的元素：</p>
<p>​                                         <strong>6</strong> | 0 | 4 | 2 | 5 | 1 | <code>3</code> | <code>9</code> | 7 | 8</p>
<p>step 9 此时<code>high</code>指向的元素为9，大于6，左移到一个小于6的数字，移动到3。此时，<code>low</code>指针和<code>high</code>指针重合了，停止<code>low</code>的迭代，不然就错过去了，6永远在第一位。</p>
<p>​                                         <strong>6</strong> | 0 | 4 | 2 | 5 | 1 | <code>3</code> | 9 | 7 | 8</p>
<p>step 10 互换<code>low</code>和<code>high</code>指向3和我们的枢纽值6：</p>
<p>​                                         3 | 0 | 4 | 2 | 5 | 1 | 6 | 9 | 7 | 8</p>
<p>至此，第一轮迭代结束。下面就是我们需要使用<strong>递归思想</strong>的时候了。这个时候大家可以看到，6已经到了6应该在的位置，但6左边的数字和右边的数字还是混乱的，这样我们就得到了两个新子序列。所以我们要不停递归下去，直到不能再分出新的子序列，并且已有的子序列均已排序完成。下面是第二轮迭代的过程，|||用来划分不同的子序列：</p>
<p>step 1 初始化，此时左右6两边各有一个独立序列：</p>
<p>​                                         <strong><em>3</em></strong> | 0 | 4 | 2 | 5 | <code>1</code>  |||  6  |||  <strong><em>9</em></strong> | 7 |<code>8</code></p>
<p>step 2 <code>high</code>和<code>low</code>的移动，右边的序列的两个指针均指向了8</p>
<p>​                                         <strong>3</strong> | 0 | <code>4</code> | 2 | 5 | <code>1</code>  |||  6  |||  <strong>9</strong> | 7 |<code>8</code></p>
<p>step 3 <code>high</code>和<code>low</code>的互换，9不可再分</p>
<p>​                                         <strong>3</strong> | 0 | <code>1</code> | 2 | 5 | <code>4</code>  |||  6  |||  8 | 7 ||| 9</p>
<p>step 4 <code>high</code>和<code>low</code>的移动</p>
<p>​                                         <strong>3</strong> | 0 | 1 | <code>2</code> | 5 |  4  |||  6  ||| <strong><em>8</em></strong> | <code>7</code> ||| 9</p>
<p>step 6 <code>high</code>和<code>low</code>的互换，第1个序列的<code>low</code>和<code>high</code>都指向2，第3个序列的<code>low</code>和<code>high</code>都指向7。互换后3，8，9不可再分</p>
<p>​                                        <strong>2</strong> | 0 | <code>1</code> |||  3  ||| <strong><em>5</em></strong> |  <code>4</code>  |||  6  ||| 7 |||  8 ||| 9</p>
<p>step 7 <code>high</code>和<code>low</code>的移动，第3个序列的<code>low</code>和<code>high</code>都指向4</p>
<p>​                                        <strong>2</strong> | 0 | <code>1</code> |||  3  ||| <strong>5</strong> |  <code>4</code>  |||  6  ||| 7 |||  8 ||| 9</p>
<p>step 8 <code>high</code>和<code>low</code>的互换，4，5，2不可再分</p>
<p>​                                        <strong><em>1</em></strong> | <code>0</code> ||| 2 |||  3  |||  4  |||  5  |||  6  ||| 7 |||  8 ||| 9</p>
<p>step 9 <code>high</code>和<code>low</code>的移动，第1个序列的<code>high</code>和<code>low</code>均指向0</p>
<p>​                                        <strong>1</strong> | <code>0</code> ||| 2 |||  3  |||  4  |||  5  |||  6  ||| 7 |||  8 ||| 9</p>
<p>step 10 <code>high</code>和<code>low</code>的移动，1和0不可再分</p>
<p>​                                        0 |||  1  |||  2  |||  3  |||  4  |||  5  |||  6  ||| 7 |||  8 ||| 9</p>
<p>最终排序完成</p>
<h4 id="2-1-2-代码编写"><a href="#2-1-2-代码编写" class="headerlink" title="2.1.2 代码编写"></a>2.1.2 代码编写</h4><p>首先，我们确定代码编写的逻辑思路，如以下</p>
<p> 1．low = left_index; high = right_index; 确定枢纽数 temp = left_index</p>
<p> 2．在low和high不同的情况下 high– 由后向前找比枢纽数小的数，low++由前向后找比枢纽数大的数</p>
<p> 3．low和high所指代的数互换位置</p>
<p> 4．在low和high相同的情况下，temp和high互换位置</p>
<p> 5．对划分后的序列进行递归，直到left不大于right时return</p>
<p>下面这个代码是在网上摘录下来的，非原创，因为这一次并不会真正用到快排算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>],n; <span class="comment">//定义全局变量，这两个变量需要在快排函数中使用 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> <span class="comment">//left和right是数组的最左边和最右边的数的下标</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> low, high, t, temp; <span class="comment">//声明下标low和high，temp为枢纽数，t是做数据交换的中间变量</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="comment">//递归结束条件</span></span><br><span class="line">       <span class="keyword">return</span>; </span><br><span class="line">                                </span><br><span class="line">    temp = a[left]; <span class="comment">//将最左边的数设为枢纽数</span></span><br><span class="line">    low = left; <span class="comment">//设置low为最左边的数字</span></span><br><span class="line">    high = right; <span class="comment">//设置high为最右边的数字</span></span><br><span class="line">    <span class="keyword">while</span>(low != high) </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//顺序很重要，要先从右边的high开始找，找到比枢纽数小下标</span></span><br><span class="line">        <span class="keyword">while</span>(a[high] &gt;= temp &amp;&amp; low &lt; high) </span><br><span class="line">            high --; </span><br><span class="line">        <span class="comment">//再找左边的low，指导找到比枢纽数大的下标</span></span><br><span class="line">        <span class="keyword">while</span>(a[low] &lt;= temp &amp;&amp; low &lt; high) </span><br><span class="line">            low ++; </span><br><span class="line">        <span class="keyword">if</span>(low &lt; high) <span class="comment">//交换low和high两个数在数组中的位置 </span></span><br><span class="line">        &#123;</span><br><span class="line">            t = a[low];</span><br><span class="line">            a[low] = a[high];</span><br><span class="line">            a[high] = t; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    a[left]=a[i]; <span class="comment">//在low和high终于相等的状况下，最终将枢纽数归位 </span></span><br><span class="line">    a[i]=temp; </span><br><span class="line">                             </span><br><span class="line">    quicksort(left,i<span class="number">-1</span>); <span class="comment">//继续处理左边的，这里是一个递归的过程 </span></span><br><span class="line">    quicksort(i+<span class="number">1</span>,right); <span class="comment">//继续处理右边的 ，这里是一个递归的过程 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2快速选择算法"><a href="#2-2快速选择算法" class="headerlink" title="2.2快速选择算法"></a>2.2快速选择算法</h3><p>快速选择算法是脱胎于快速排序算法，两者都由C. A. R. Hoare提出，两者分别都是在排序问题和top-k问题中最高效的算法。同时有了快速排序的基础，快速选择会更加的快速。</p>
<h4 id="2-2-1算法例子及原理"><a href="#2-2-1算法例子及原理" class="headerlink" title="2.2.1算法例子及原理"></a>2.2.1算法例子及原理</h4><p>我们仍采用上面的一组数据，但换个问题</p>
<p>问题：有这么一组数 6  8  4  2  7  1  9  3  5  0，选出最大的两个数。</p>
<p>step1 首先我们确定我们需要选择的这一组数字：</p>
<p>​                     6 | 8 | 4 | 2 | 7 | 1 | 9 | 3 | 5 | 0</p>
<p>step2 做一次快排</p>
<p>​                                         3 | 0 | 4 | 2 | 5 | 1 |||  6  ||| 9 | 7 | 8</p>
<p>step3 选择6右侧的序列</p>
<p>​                                         9 | 7 | 8</p>
<p>step4 判断，3个数字大于2，因此对左边的数再次快排，选出数字9</p>
<p>​                                         8 | 7 |||  9</p>
<p>step5 判断，9是一个数字，小于1，开始递归，在9左边的两个数字8和7中选择top - 1，对8, 7做快排，选出８</p>
<p>​                                        7 ||| 8</p>
<p>step6 确定为８和９</p>
<h4 id="2-2-2代码编写"><a href="#2-2-2代码编写" class="headerlink" title="2.2.2代码编写"></a>2.2.2代码编写</h4><p>首先我们确定代码的编写流程</p>
<p> 1．low = left_index; high = right_index; 确定枢纽数 temp = left_index</p>
<p> 2．在low和high不同的情况下 high– 由后向前找比枢纽数小的数，low++由前向后找比枢纽数大的数</p>
<p> 3．low和high所指代的数互换位置</p>
<p> 4．选出目标的那一部分数组，做大小的判断，我们假设它有ｍ个数据</p>
<p> 5．若ｍ &gt; k，则重新对目标数组做快排</p>
<p>　　若m = k，返回该数组</p>
<p>　　若m &lt; k，对非目标数组的那部分数组对以 k - m为目标做快排</p>
<p> 5．直到m = k，返回该数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TYPE&gt;</span><br><span class="line"><span class="function">TYPE <span class="title">qselect</span><span class="params">(TYPE* pArray, <span class="keyword">int</span> k, <span class="keyword">int</span> li, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi - li &lt;= <span class="number">1</span>) <span class="keyword">return</span> pArray[k];</span><br><span class="line">    <span class="keyword">int</span> j = li; <span class="built_in">std</span>::swap(pArray[j], pArray[k]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = j = li + <span class="number">1</span>; i &lt; hi; i++)</span><br><span class="line">        <span class="keyword">if</span> (pArray[i] &lt; pArray[li]) <span class="built_in">std</span>::swap(pArray[j++], pArray[i]);</span><br><span class="line">    <span class="built_in">std</span>::swap(pArray[--j], pArray[li]);</span><br><span class="line">    <span class="keyword">if</span> (k &lt; j) <span class="keyword">return</span> qselect(pArray, k, li, j);</span><br><span class="line">    <span class="keyword">if</span> (k &gt; j) <span class="keyword">return</span> qselect(pArray, k - j, j + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">return</span> pArray[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaocheng Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs of Zhaocheng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/05/基于LBS的出租车检索内核实现/" itemprop="url">基于LBS的出租车检索内核实现.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-05T23:14:35+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于LBS的打车APP开发"><a href="#基于LBS的打车APP开发" class="headerlink" title="基于LBS的打车APP开发"></a>基于LBS的打车APP开发</h1><p><strong>功能描述</strong>：现在我们想要开发一个类似于滴滴打车的软件，主要想要实现下面的两个功能：</p>
<p>在给定的一张北京地图上，有诸多的出租车车辆</p>
<p>功能1: range_query，在一个范围内，例如我们的屏幕范围内，显示出所有的出租车信息</p>
<p>功能2: knn_query，用户指定起点，可以获得距离最近的k辆车</p>
<p><strong>面临问题与解决方案</strong></p>
<p>对于range_query</p>
<ul>
<li>如何存储北京的地图信息，使得信息检索最快，使用(<strong>使用网格索引</strong>与<strong>二维地图一维化</strong>存储，见第4部分)？</li>
<li>如何快速查找某一单位地域范围内的所有车辆信息(使用<strong>双向列表</strong>数据结构，见第2部分)？</li>
<li>如何快速查找某一车辆在哪一单位地域(使用<strong>哈希表</strong>数据结构，见第3部分)？</li>
</ul>
<p>对于knn_query</p>
<ul>
<li>如何快速查找距离最近(欧氏距离)的车辆(使用<strong>小顶堆</strong>数据结构，见第7部分)？</li>
<li>如何实现在堆中查找距离时的剪枝，从而提高查找效率(使用<strong>Bitmap</strong>数据结构，见第6部分)？</li>
</ul>
<p>下面就是正文了，正文的描述由下面的结构组成：</p>
<ol>
<li>介绍本次项目用到的<strong>C语言的基本知识</strong>以及<strong>相关概念</strong></li>
<li>介绍实现range_query的相关<strong>数据结构的理论</strong>及<strong>代码设计与编写</strong></li>
<li>实现range_query</li>
<li>介绍实现knn_query的相关<strong>数据结构的理论</strong>及<strong>代码设计与编写</strong></li>
<li>实现knn_query</li>
</ol>
<h2 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1.基本知识"></a>1.基本知识</h2><h3 id="1-1-索引相关知识"><a href="#1-1-索引相关知识" class="headerlink" title="1.1 索引相关知识"></a>1.1 索引相关知识</h3><p><strong>索引</strong>：索引是在一个数据集当中，索引无需对整个数据集进行扫描，就可以在其中找到所需要的数据的的一种就结构．注意以下两点：</p>
<ul>
<li>索引不是一个特定的结构，任何可以实现上述功能均可成为索引．</li>
<li>索引不是在物理上而是从逻辑上对数据进行排序．</li>
<li>索引的本质是拿空间换时间</li>
</ul>
<p><strong>空间索引</strong>: 对于一些空间数据，数据是多维度的(例如一些线段是二维的)，不能够通过简单的数据排序来进行建立索引，因此需要其他的算法来建立空间索引，主要有以下两种：</p>
<ul>
<li>基于最小包容块的算法(R-tree)</li>
<li>基于空间细分的方法(网格划分的索引)</li>
</ul>
<p>这里我们使用的是网格划分的索引。</p>
<h3 id="1-2-C中的位操作"><a href="#1-2-C中的位操作" class="headerlink" title="1.2 C中的位操作"></a>1.2 C中的位操作</h3><p>当我们声明一个为0的char1变量(有8 bit)时，我们得到了下面的这个数据</p>
<p>​                                                                 <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code>  </p>
<p>当我们声明一个为3的char2变量(有8 bit)时，我们得到了下面的这个数据</p>
<p>​                                                                 <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code> <code>1</code></p>
<ul>
<li><p><strong>位的与操作(&amp;)</strong></p>
<p>对每一个bit位分别进行与操作，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char1 &amp; char2</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code></p>
</li>
<li><p><strong>位的或操作(|)</strong></p>
<p>对每一个bit位分别进行或操作，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char1 | char2</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code> <code>1</code></p>
</li>
<li><p><strong>位的左移操作(&lt;&lt;)</strong></p>
<p>将所有bit位向左移一位，例如将char2的每一位左移2位，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char2 &lt;&lt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>最终的结果如下，转化为十进制为12</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code> <code>1</code> <code>0</code> <code>0</code></p>
</li>
<li><p><strong>位的右移操作(&lt;&lt;)</strong></p>
<p>将所有bit位向右移一位，例如将char2的每一位右移1位，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char2 &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>最终的结果如下，转化为十进制为</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code></p>
</li>
<li><p><strong>位的取反操作(~)</strong></p>
<p>将所有bit位每一位进行取反</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~char2</span><br></pre></td></tr></table></figure>
<p>最终的结果如下，转化为十进制为1</p>
<p>​                                                          <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>0</code> <code>0</code></p>
</li>
<li><p><strong>位的异或运算(^)</strong></p>
<p>若参加运算的两个二进制位值相同则为0，否则为1，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char1 ^ char2</span><br></pre></td></tr></table></figure>
<p>运算结果为：</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code> <code>1</code></p>
</li>
</ul>
<h3 id="1-3-数据存储相关知识"><a href="#1-3-数据存储相关知识" class="headerlink" title="1.3 数据存储相关知识"></a>1.3 数据存储相关知识</h3><p>在本次编程这种涉及到了大量的<strong>分配内存</strong> 的操作，和之前变量声明有很大的不同，故记录。</p>
<ul>
<li><p><strong>栈区(stack)</strong>－－由编译器自动分配和释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。声明方式就是在C基础里学到的最基础的声明方式，会在函数结束的时候释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lbs_hashtable_t</span> hashtable;<span class="comment">//声明一个hashtable类型的变量hashtable</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>堆区(heap)</strong>－－一般由程序员分配和释放，若程序员不释放，程序结束时可能由OS回收，注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。在函数结束时仍然不会消失。常用的函数有<code>malloc</code>，<code>calloc</code>，<code>realloc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lbs_hashtable_t</span>* hashtable = (<span class="keyword">lbs_hashtable_t</span>*)<span class="built_in">malloc</span>(<span class="number">12</span> * <span class="keyword">sizeof</span>(<span class="keyword">lbs_hashtable_t</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全局区(静态区)(static)</strong>——全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放，声明使用<code>statistic</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">lbs_hashtable_t</span>* hashtable</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-4-宏的相关定义"><a href="#1-4-宏的相关定义" class="headerlink" title="1.4 宏的相关定义"></a>1.4 宏的相关定义</h3><p>宏简单的说就是字符串的替代操作，使用<code>#define</code>关键字来书写。</p>
<p>这里主要说明两种宏</p>
<ol>
<li>替代数值的宏</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LAT 103</span></span><br></pre></td></tr></table></figure>
<p>在后面的所有代码当中出现了<code>MIN_LAT</code>就被替换成了103</p>
<ol>
<li>作为函数的宏</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> #<span class="meta-keyword">define</span> lbs_queue_init(q) \</span></span><br><span class="line">  (q)-&gt;prev = (q);\</span><br><span class="line">  (q)-&gt;next = (q);</span><br></pre></td></tr></table></figure>
<p>作为函数的宏和普通的函数有些许的不同，不同在于:</p>
<p>(1) 宏不需要声明形参变量的类型</p>
<p>(2) 宏是以一句话终结作为一个宏识别的结束，而不是以分号</p>
<h2 id="2-双向列表数据结构"><a href="#2-双向列表数据结构" class="headerlink" title="2.双向列表数据结构"></a>2.双向列表数据结构</h2><p><strong>双向列表</strong>是在本次实现<strong>网格索引</strong>和<strong>哈希表</strong>的关键以及基础，因此先进行介绍双向列表．</p>
<h3 id="2-1-双向链表结构设计"><a href="#2-1-双向链表结构设计" class="headerlink" title="2.1 双向链表结构设计"></a>2.1 双向链表结构设计</h3><p><strong>双向列表</strong>的样子如下图所示，一个双向列表由多个<strong>双向列表的节点</strong>组成，在每一个节点当中我们分别使用两个指针指向前面和后面的节点，当我们遍历时，只需要取出该节点当中存储的下一个节点的地址，就可以快速访问下一个节点。</p>
<p><strong>注意</strong>：头结点(x1, y1)一般设置为空节点，这样方便新的节点的插入操作。</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-07-25 19-44-37屏幕截图.png" alt="2018-07-25 19-44-37屏幕截图"></p>
<p>首先熟悉一下双向列表的组成，双向列表的每一个节点由两部分组成：数据和指针．</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-07-25 19-47-28屏幕截图.png" alt="2018-07-25 19-47-28屏幕截图"></p>
<p>其中：</p>
<p>data属于数据域，是记录车辆的数据的区域；</p>
<p>prev属于指针域，是指向前一个node的指针；</p>
<p>next属于指针域，是指向后一个node的指针；</p>
<p>这里我们将数据域和指针域分别定义在<strong>不同的头文件</strong>里，以方便后期数据域的修改(在后期的<strong>哈希表数据结构</strong>和<strong>网格索引</strong>当中都使用到了指针域，但数据域有所不同)，下面是指针域部分，在lbs_queue.h头文件中书写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_queue.h</span></span><br><span class="line"><span class="comment">//定义指向前和后的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_queue_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lbs_queue_s</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lbs_queue_s</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">lbs_queue_t</span></span><br><span class="line"><span class="comment">//下接操作，接口１</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-车辆点结构设计"><a href="#2-2-车辆点结构设计" class="headerlink" title="2.2 车辆点结构设计"></a>2.2 车辆点结构设计</h3><p>这可以理解为一个车辆节点的数据结构，也可以理解为前面双向列表的数据域部分。<strong>第一行引入了双向列表</strong><code>queue。</code>主要涉及经纬度信息，车辆id信息，时间戳信息等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_defs.h</span></span><br><span class="line"><span class="comment">//定义数据域，并加入指针域，形成完整节点node</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lbs_queue.h"</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_mov_node_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">lbs_queue_t</span> <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">double</span> lon;</span><br><span class="line">    <span class="keyword">double</span> lat;</span><br><span class="line">    <span class="keyword">uint32_t</span> id;</span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp;</span><br><span class="line">&#125;<span class="keyword">lbs_mov_node_t</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-链表的相关操作"><a href="#2-3-链表的相关操作" class="headerlink" title="2.3 链表的相关操作"></a>2.3 链表的相关操作</h3><p>在定义了数据域和链表域以后就是定义链表指针的操作了，链表的操作主要是<strong>针对节点的操作</strong>，包括节点的<strong>初始化</strong>(建立一个空节点)，<strong>插入</strong>，<strong>删除</strong>和<strong>判空</strong>等，由于大一学习过，不做详细的解说．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_queue.h</span></span><br><span class="line"><span class="comment">//接口１</span></span><br><span class="line"><span class="comment">//初始化一个空的queue有节点,q是宏的参数，与函数不同，可以不做数据类型的声明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lbs_queue_init(q) \</span></span><br><span class="line">  (q)-&gt;prev = (q);\</span><br><span class="line">  (q)-&gt;next = (q);</span><br><span class="line"><span class="comment">//删除q节点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lbs_queue_remove(q) \</span></span><br><span class="line">  (q)-&gt;prev-&gt;next = (q)-&gt;next;\</span><br><span class="line">  (q)-&gt;next-&gt;prev = (q)-&gt;prev;</span><br><span class="line"><span class="comment">//把q插在h后面</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lbs_queue_insert_head(h,q)\</span></span><br><span class="line">  (q)-&gt;prev-&gt;next = (h);\</span><br><span class="line">  (h)-&gt;next       = (q);\</span><br><span class="line">  (q)-&gt;next       = (h)-&gt;next; \</span><br><span class="line">  (h)-&gt;next       = (q)</span><br><span class="line"><span class="comment">//判断链表是否为空(h节点下一个若是自己则为空)</span></span><br><span class="line">#define lbs_queue_empty(h)\</span><br><span class="line">  (h)-&gt;next == (h)</span><br></pre></td></tr></table></figure>
<h2 id="3-哈希表数据结构"><a href="#3-哈希表数据结构" class="headerlink" title="3.哈希表数据结构"></a>3.哈希表数据结构</h2><p>为什么要引入哈希表呢?答案是为了实现车辆快速的查找，说白了也是为了构建一种类似于索引的结构．具体会在后面讲述，暂时只是整理．</p>
<h3 id="3-1-算法原理"><a href="#3-1-算法原理" class="headerlink" title="3.1 算法原理"></a>3.1 算法原理</h3><p>哈希表的原理如下：对于一串关键字(我们称之为数字1)，通过<strong>哈希函数</strong>的计算，得到另一个数字(数字２)，此时这串得到的数字2就是该关键字对应的数据存储的物理地址．所以下一次我们得到了关键字数字1，想要查看该关键字对应的相关信息，只需要进行<strong>一次哈希计算</strong>，我们就知道它存储在了什么<strong>物理地址(数字2)</strong>上．然后我们在该物理地址上寻找就能找到这类信息．<strong>避免</strong>了进行一次次<strong>迭代</strong>的过程．</p>
<p>举例说明，我们获得了id = k，哈希函数是h(key)，则它存储的物理地址就是h(k)．常用的哈希函数方法如下：</p>
<ul>
<li>直接定址法</li>
<li>数字分析法</li>
<li>除留取余法</li>
</ul>
<p>下面我们选择最简单的方法<strong>除留取余法</strong>做个示范，这也是我们在后面真正的试验中会使用的方法．<strong>除留取余法</strong>就是哈希函数定义为h(key) = key%q，注意q有以下选择规则:</p>
<ul>
<li>q不应大于哈希表的长度</li>
<li>q应该尽量是一个质数</li>
</ul>
<p>简单起见，我们要定义哈希表的长度m = 8，q = 7．我们有一组关键字为{5,6,7,22,81,19,34 }，我们进行一下的计算过程，我们首先计算前五个数值:</p>
<p>5 % 7 = 5,  6 % 7 = 6,  7 % 7 = 0,  22%7 = 1,  81%7 = 4</p>
<table>
<thead>
<tr>
<th>h(key)</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td>7</td>
<td>22</td>
<td></td>
<td></td>
<td>81</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>这里的h(key)就是计算后存储的物理地址，key就是我们的关键字．然而在计算19和34时，却出现下面的问题：</p>
<p>19 % 7 = 5,   34%7 = 6  </p>
<p>物理位置5和6已经被5和6这两个关键字填充了，我们称之为发生了<strong>冲突</strong>．我们的解决方案就是利用上面的<strong>双向列表数据结构</strong>,得到以下的结构：</p>
<table>
<thead>
<tr>
<th>h(key)</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td>7</td>
<td>22</td>
<td></td>
<td></td>
<td>81</td>
<td>5</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>19</td>
<td>34</td>
</tr>
</tbody>
</table>
<p>转化一下形式就成了下图的样子:</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-07-26 07-43-43屏幕截图.png" alt="2018-07-26 07-43-43屏幕截图"></p>
<h3 id="3-2-哈希表节点结构设计"><a href="#3-2-哈希表节点结构设计" class="headerlink" title="3.2 哈希表节点结构设计"></a>3.2 哈希表节点结构设计</h3><p>首先我们看到在每一个<strong>链表节点</strong>的最前面有一个都有一个<strong>哈希表节点</strong>，下面我们首先实现哈希表节点，哈希节点主要需要存储</p>
<ul>
<li>一个可以进行链接<strong>前节点</strong>和<strong>后节点</strong>的双向列表queue结构</li>
<li>一个可以指向存储车辆数据mov_node地址的指针</li>
<li>一个cell 的 id</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_hashtable.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_hashnode_s</span>&#123;</span></span><br><span class="line">  <span class="comment">//我们需要一个链表来连接前面的和后面的节点</span></span><br><span class="line">  <span class="keyword">lbs_queue_t</span> <span class="built_in">queue</span>;</span><br><span class="line">  <span class="comment">//我们需要一个指向mov_node的指针(并不真正用它存储数据)</span></span><br><span class="line">  <span class="keyword">lbs_mov_node_t</span>* mov_node;</span><br><span class="line">  <span class="comment">//一个cell的id</span></span><br><span class="line">  <span class="keyword">int</span> cell_id;</span><br><span class="line">&#125;<span class="keyword">lbs_hashnode_t</span></span><br><span class="line"><span class="comment">//接口2</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-哈希表结构设计"><a href="#3-3-哈希表结构设计" class="headerlink" title="3.3 哈希表结构设计"></a>3.3 哈希表结构设计</h3><p>随后我们需要编写hashtable的结构(hashtable由多个hashnode组成)，这里需要一下数据:</p>
<ul>
<li>hashnode的数量Capacity</li>
<li>node已经被占用的数量size</li>
<li>指向下一个hashnode的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_hashtable_s</span>&#123;</span></span><br><span class="line">  <span class="comment">//哈希表节点的个数(多少个hashnode)</span></span><br><span class="line">  <span class="keyword">int</span> capacity;</span><br><span class="line">  <span class="comment">//哈希节点被占用的个数</span></span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">//一个声明存储hashnode的头地址</span></span><br><span class="line">  <span class="keyword">lbs_hashnode_t</span>* hash_nodes;</span><br><span class="line">&#125;<span class="keyword">lbs_hashtable_t</span></span><br><span class="line"><span class="comment">//接口3</span></span><br></pre></td></tr></table></figure>
<p>继续定义哈希表的方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口3</span></span><br><span class="line"><span class="comment">//初始化一个hashtable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_init</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable)</span></span>;</span><br><span class="line"><span class="comment">//销毁一个hashtable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_destroy</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable)</span></span>;</span><br><span class="line"><span class="comment">//设置一个hashtable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_set</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable, <span class="keyword">uint32_t</span> id, <span class="keyword">lbs_mov_node_t</span>* lbs_mov_node, <span class="keyword">int</span> cell_id)</span></span>;</span><br><span class="line"><span class="comment">//提取一个hashtable的信息</span></span><br><span class="line"><span class="keyword">lbs_hashnode_t</span>* lbs_hashtable_get(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable, <span class="keyword">uint32_t</span> id);</span><br></pre></td></tr></table></figure>
<p>下面介绍每一个方法的实现方法(实现在cpp中文件编写即可):</p>
<h3 id="3-4-哈希表的初始化"><a href="#3-4-哈希表的初始化" class="headerlink" title="3.4 哈希表的初始化"></a>3.4 哈希表的初始化</h3><p>首先是结构体的<strong>初始化</strong>，结构体的初始化就是给init函数传入变量，使得函数中的每个值赋予结构体内的变量:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_hashtable.cpp</span></span><br><span class="line"><span class="comment">//初始化一个hashtable_node</span></span><br><span class="line"><span class="comment">//注意传入的是指针的hashtable类型，因此需要malloc分配动态内存，使用-&gt;访问成员</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_init</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable)</span></span>&#123;</span><br><span class="line">  lbs_hashtable-&gt;size = <span class="number">0</span>;</span><br><span class="line">  lbs_hashtable-&gt;capacity-&gt; = <span class="number">19997</span>;</span><br><span class="line">  <span class="comment">//((lbs_hashtable_t *)强制数据类型转化，malloc动态分配，sizeof()计算内存大小，)</span></span><br><span class="line">  lbs_hashtable-&gt;hashnode = (<span class="keyword">lbs_hashtable_t</span> *)<span class="built_in">malloc</span>\</span><br><span class="line">      (lbs_hashtable-&gt;capacity * <span class="keyword">sizeof</span>(lbs_hashnode_s))</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lbs_hashtable-&gt;Capacity; i++)&#123;</span><br><span class="line">    <span class="comment">//当传入的是struct变量，而不是指针，例如下文中的queue，使用.访问成员，不用分配内存</span></span><br><span class="line">    lbs_queue_init(&amp;(lbs_hashtable-&gt;hash_nodes[i].<span class="built_in">queue</span>))     </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-哈希表析构函数"><a href="#3-5-哈希表析构函数" class="headerlink" title="3.5 哈希表析构函数"></a>3.5 哈希表析构函数</h3><p>其次是结构体的析构函数，析构函数是对于有malloc分配内存的指针，使用free()析构掉．由于hashtable中的hashnode是一个连续的数组，因此只需要析构头地址。结构体的析构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上,lbs_hashtable.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_destroy</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable)</span></span>&#123;</span><br><span class="line">  lbs_hashtable-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">  lbs_hashtable-&gt;size = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">free</span>(lbs_hashtable-&gt;hashnode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6-设置一个哈希节点并插入哈希表"><a href="#3-6-设置一个哈希节点并插入哈希表" class="headerlink" title="3.6 设置一个哈希节点并插入哈希表"></a>3.6 设置一个哈希节点并插入哈希表</h3><p>设置一个节点，初始化一个hashnode，并且将存入数据的hashnode插入一个列表当中．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上,lbs_hashtable.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_set</span><span class="params">(<span class="keyword">lbs_hashtable_t</span> * lbs_hashtable,</span></span></span><br><span class="line">                      unit32_t id, lbs_mov_node_t * lbs_mov_node, int cell_id):&#123;</span><br><span class="line">  hashnode-&gt;cell_id = cell_id;</span><br><span class="line">  hashnode-&gt;mov_node = lbs_move_node;</span><br><span class="line">  lbs_queue_init(hashnode-&gt;<span class="built_in">queue</span>);</span><br><span class="line">  <span class="keyword">int</span> index = id % (lbs_hashtable-&gt;capacity);</span><br><span class="line">  lbs_queue_insert_head(lbs_hashtable-&gt;hash_nodes[index].<span class="built_in">queue</span>,hashnode-&gt;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-获取哈希节点信息"><a href="#3-7-获取哈希节点信息" class="headerlink" title="3.7 获取哈希节点信息"></a>3.7 获取哈希节点信息</h3><p>根据一辆车的id提取一个hashtable的信息．其基本呢逻辑如下：</p>
<ul>
<li>通过id计算某一车辆信息存储的哈希表头位置</li>
<li>对哈希表内存储的双向链表进行一一迭代，找到该id车辆所对应的信息，如果没有的话，返回NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上,lbs_hashtable.cpp</span></span><br><span class="line"><span class="keyword">lbs_hashnode_t</span>* lbs_hashtable_get(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable, <span class="keyword">uint32_t</span> id)&#123;</span><br><span class="line">  <span class="comment">//初始化头结点和头结点的下一个节点</span></span><br><span class="line">  index = id % (lbs_hashtable-&gt;capacity);</span><br><span class="line">  <span class="keyword">lbs_hashnode_t</span>* headnode = lbs_hashtable-&gt;hashnode+index;</span><br><span class="line">  <span class="keyword">lbs_hashnode_t</span>* curnode = (<span class="keyword">lbs_hashnode_t</span>* )headnode-&gt;<span class="built_in">queue</span>.next;</span><br><span class="line">  <span class="comment">//不断迭代，直到找到相同的id为止</span></span><br><span class="line">  <span class="keyword">while</span>(headnode != curnode)&#123;</span><br><span class="line">    <span class="keyword">if</span> (curnode-&gt;mov_node-&gt;id == id)&#123;</span><br><span class="line">      <span class="keyword">return</span> curnode;      </span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      curnode = (<span class="keyword">lbs_hashnode_t</span>* )curnode-&gt;<span class="built_in">queue</span>.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lbs_hashtable.cpp结束</span></span><br></pre></td></tr></table></figure>
<h2 id="4-二维数组的网格降维处理"><a href="#4-二维数组的网格降维处理" class="headerlink" title="4. 二维数组的网格降维处理"></a>4. 二维数组的网格降维处理</h2><p>在我们获得一个二维的区域，首先我们需要将其网格化，网格化之后，我们就获得了每一个网格的编号等信息，按照编号进行存储，我们就<strong>从二位数组转化成了一维数组</strong>，实现了降维的操作．这样降维处理的主要原因是一维数组分配的是<strong>一组连续的数组</strong>，为对于二维数组则分配的空间则并不连续，影响数据处理的速度。</p>
<p>在定义网格结构体之前，我们首先想到如下的网格结构，有一下看点：</p>
<ul>
<li>一个地图被分为了许多的cell</li>
<li>每一个cell里存储这个cell里的车辆的信息</li>
<li>注意cell的编号从0—12，在物理存储中是连续的，因此转化为了一维的数组</li>
</ul>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-07-30 00-17-25屏幕截图.png" alt="2018-07-30 00-17-25屏幕截图"></p>
<h3 id="4-1-网格结构设计及其属性"><a href="#4-1-网格结构设计及其属性" class="headerlink" title="4.1 网格结构设计及其属性"></a>4.1 网格结构设计及其属性</h3><ul>
<li>每一个网格都有很多的cell</li>
<li>每一个cell里都要初始化一个<strong>空的双向列表</strong>(dammy node)来存储出租车信息。</li>
<li>每一个格子都应该有一个<strong>进程锁</strong>，来确保不会有多个用户同时访问</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_grid.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_cell_s</span> &#123;</span></span><br><span class="line">  <span class="comment">//dammy node</span></span><br><span class="line">  <span class="keyword">lbs_mov_node_t</span> dammy_node;</span><br><span class="line">  <span class="comment">//锁</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125; <span class="keyword">lbs_cell_t</span>;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<p>其次，我们定义网格数据结构的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_grid_s</span> &#123;</span></span><br><span class="line">  <span class="comment">//row num of grid</span></span><br><span class="line">  <span class="keyword">int</span> row_num;</span><br><span class="line">  <span class="comment">//col num of grid</span></span><br><span class="line">  <span class="keyword">int</span> col_num;</span><br><span class="line">  <span class="comment">//cell width</span></span><br><span class="line">  <span class="keyword">double</span> cell_width;</span><br><span class="line">  <span class="comment">//cell height</span></span><br><span class="line">  <span class="keyword">double</span> cell_height;</span><br><span class="line">  <span class="comment">//grid lon minimum value</span></span><br><span class="line">  <span class="keyword">double</span> lon_min;</span><br><span class="line">  <span class="comment">//grid lat minimum value</span></span><br><span class="line">  <span class="keyword">double</span> lat_min;</span><br><span class="line">  <span class="comment">//哈希表</span></span><br><span class="line">  <span class="keyword">lbs_hashtable_t</span> hash_table;</span><br><span class="line">  <span class="comment">//所有的cells</span></span><br><span class="line">  <span class="keyword">lbs_cell_t</span>* cell;</span><br><span class="line">&#125; <span class="keyword">lbs_grid_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网络的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_init</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon1, <span class="keyword">double</span> lon2, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lat2, <span class="keyword">int</span> row_num, <span class="keyword">int</span> col_num)</span></span>;</span><br><span class="line"><span class="comment">//网格的删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_destroy</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid)</span></span>;</span><br><span class="line"><span class="comment">//更新移动位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_update</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">uint64_t</span> timestamp, <span class="keyword">uint32_t</span> id)</span></span>;</span><br><span class="line"><span class="comment">//计算cell row</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_row</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lat)</span></span>;</span><br><span class="line"><span class="comment">//计算cell col</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_col</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon)</span></span>;</span><br><span class="line"><span class="comment">//计算cell id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_id</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_row, <span class="keyword">int</span> cell_col)</span></span>;</span><br><span class="line"><span class="comment">//给出id，返回row和col</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lbs_grid_cell_row_col</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_id, <span class="keyword">int</span>* cell_row, <span class="keyword">int</span>* cell_col)</span></span>;</span><br><span class="line"><span class="comment">//获取cell_id里面的cell</span></span><br><span class="line"><span class="keyword">lbs_cell_t</span>* lbs_grid_cell(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_id);</span><br><span class="line"><span class="comment">//结束lbs_grid.h</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2网格数据结构初始化"><a href="#4-2网格数据结构初始化" class="headerlink" title="4.2网格数据结构初始化"></a>4.2网格数据结构初始化</h3><p>在<code>.cpp</code>文件中分别对每一个函数进行编写，首先是对网格的初始化，这里注意：</p>
<ul>
<li>由于cell是一个一维的数组，因此在初始化时需要使用<code>malloc</code>分配连续的空间。</li>
<li>在分配给每个cell存储空间以后，还需要对cell里面的链表进行初始化：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_grid.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_init</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon1, <span class="keyword">double</span> lon2, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lat2, <span class="keyword">int</span> row_num, <span class="keyword">int</span> col_num)</span></span>&#123;</span><br><span class="line"> lbs_grid-&gt;row_num = row_num;</span><br><span class="line"> lbs_grid-&gt;col_num = col_num;</span><br><span class="line"> lbs_grid-&gt;lon_min = lon1;</span><br><span class="line"> lbs_grid-&gt;lat_min = lat1;</span><br><span class="line"> lbs_grid-&gt;cell_width = (lon2-lon1)/col_num;</span><br><span class="line"> lbs_grid-&gt;cell_height = (lat2-lat1)/row_num; </span><br><span class="line"> lbs_hashtable_init(&amp;lbs_grid-&gt;hashtable);</span><br><span class="line"> lbs_grid-&gt;cell = (<span class="keyword">lbs_cell_t</span>* )<span class="built_in">malloc</span>(row_num*col_num*<span class="keyword">sizeof</span>(<span class="keyword">lbs_cell_t</span>));</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row_num*col_num; i++)&#123;</span><br><span class="line">   lbs_queue_init(&amp;(lbs_grid-&gt;cell[i].dammy_node.<span class="built_in">queue</span>));     </span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-网络数据结构析构"><a href="#4-3-网络数据结构析构" class="headerlink" title="4.3 网络数据结构析构"></a>4.3 网络数据结构析构</h3><p>网格的析构，由于每一个内部都被赋予了初值——<code>dammy_node</code>，所以在释放内存的时候需要对每一个<code>cell</code>的地址进行释放内存。:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_destroy</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid)</span></span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(lbs_grid-&gt;cell)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row_num*col_num; i == <span class="number">0</span>; i--)&#123;</span><br><span class="line">      <span class="built_in">free</span>(cell + i);    </span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-在屏幕发生变化时更新节点信息"><a href="#4-4-在屏幕发生变化时更新节点信息" class="headerlink" title="4.4 在屏幕发生变化时更新节点信息"></a>4.4 在屏幕发生变化时更新节点信息</h3><p>网格数据内车辆信息的更新，分为以下几个步骤完成：</p>
<ul>
<li>1.根据传入的车辆lon, lat 号计算该点所在的new_cell_id</li>
<li>2.根据传入的id 号计算该节点所在的hashnode，并从hashtable中获取该车辆原本的old_cell_id</li>
<li>3.判断该hashnode是否为空，为空则说明这辆车是新到的，所以加入hash表当中；如果不为空，则说明这辆车原本就存在，进而转入下一次判断</li>
<li>4.判断new_cell_id是否等于old_cell_id，如果等于的话，不做改变；否则删除原hashnode节点，插入新hashnode节点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_update</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">uint64_t</span> timestamp, <span class="keyword">uint32_t</span> id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">lbs_hashnode_t</span>* hashnode = lbs_hashtable_get(&amp;(lbs_grid-&gt;hashtable), id);</span><br><span class="line">  <span class="keyword">int</span> cell_row_new = lbs_grid_cell_row(&amp;(lbs_grid), lat);</span><br><span class="line">  <span class="keyword">int</span> cell_col_new = lbs_grid_cell_col(&amp;(lbs_grid), lon);</span><br><span class="line">  <span class="keyword">int</span> cell_id_new = lbs_grid_col(cell_row, cell_col);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在没有该节点的情况下</span></span><br><span class="line">  <span class="keyword">if</span> (hashnode == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//更新mov_node</span></span><br><span class="line">    <span class="keyword">lbs_mov_node_t</span>* new_lbs_mov_node = (<span class="keyword">lbs_mov_node_t</span>* )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">lbs_mov_node_t</span>));</span><br><span class="line">    <span class="comment">//new_lbs_queue_init(lbs_mov_node-&gt;queue);</span></span><br><span class="line">    new_lbs_mov_node-&gt;lon = lon;</span><br><span class="line">    new_lbs_mov_node-&gt;lat = lat;</span><br><span class="line">    new_lbs_mov_node-&gt;id = id;</span><br><span class="line">    new_lbs_mov_node-&gt;timestamp = timestamp;</span><br><span class="line">    <span class="comment">//重设hashnode</span></span><br><span class="line">    <span class="keyword">int</span> temp = lbs_hashtable_set(&amp;(lbs_grid-&gt;lbs_hashtable), id, new_lbs_mov_node, cell_id_new);</span><br><span class="line">    lbs_queue_insert_head(&amp;(lbs_grid-&gt;cell[cell_id_new].dammy_node.<span class="built_in">queue</span>), &amp;(new_lbs_mov_node.<span class="built_in">queue</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在需要更新的情况下</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cell_id_new != cell_id_old)&#123;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;lon = lon;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;lat = lat;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;timestamp = timestamp;</span><br><span class="line">      hashnode-&gt;cell_id = cell_id_new;</span><br><span class="line">      lbs_queue_remove(&amp;(hashnode-&gt;mov_node-&gt;<span class="built_in">queue</span>));</span><br><span class="line">      lbs_queue_insert_head(&amp;(lbs_grid-&gt;cell[cell_id_new].dammy_node.<span class="built_in">queue</span>), &amp;(hashnode-&gt;mov_node-&gt;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要更新的情况下</span></span><br><span class="line">    <span class="keyword">else</span> (cell_id_new == cell_id_old)&#123;</span><br><span class="line">      <span class="keyword">int</span> cell_id_old = hashnode -&gt; cell_id;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;lon = lon;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;lat = lat;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;timestamp = timestamp;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-获取网格属性"><a href="#4-5-获取网格属性" class="headerlink" title="4.5 获取网格属性"></a>4.5 获取网格属性</h3><p>最后还有一些简单的函数，用来实现</p>
<ul>
<li>根据id获得行号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//计算cell row</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_row</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lat)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> row = (lat - (lbs_grid-&gt;lat_min)) / (lbs_grid-&gt;cell_height);</span><br><span class="line">  <span class="keyword">return</span> row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据id获得列号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//计算cell col</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_col</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> col = (lon - (lbs_grid-&gt;lon_min)) / (lbs_grid-&gt;cell_width);</span><br><span class="line">  <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据col和row获得id</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//计算cell id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_id</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_row, <span class="keyword">int</span> cell_col)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = (lbs_grid-&gt;col_num) * cell_row + cell_col;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据id同时获得行和列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//计算row 和 col</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lbs_grid_cell_row_col</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_id, <span class="keyword">int</span>* cell_row, <span class="keyword">int</span>* cell_col)</span> </span>&#123;</span><br><span class="line">  *cell_row = cell_id / lbs_grid-&gt;col_num;</span><br><span class="line">  *cell_col = cell_id % lbs_grid-&gt;col_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据id获取整个cell</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//获取cell id 里面的 cell</span></span><br><span class="line"><span class="keyword">lbs_cell_t</span>* lbs_grid_cell(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_id)&#123;</span><br><span class="line">  <span class="keyword">if</span> (lbs_grid!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(lbs_grid-&gt;cell[cell_id]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lbs_grid.cpp结束</span></span><br></pre></td></tr></table></figure>
<h2 id="5-实现网格范围索引-range-query"><a href="#5-实现网格范围索引-range-query" class="headerlink" title="5. 实现网格范围索引(range_query)"></a>5. 实现网格范围索引(range_query)</h2><h3 id="5-1进行网格范围索引的最终结构"><a href="#5-1进行网格范围索引的最终结构" class="headerlink" title="5.1进行网格范围索引的最终结构"></a>5.1进行网格范围索引的最终结构</h3><p>终于到了可以实现range_query的时候了，上面讲解了许多的数据结构都是为了可以实现这个功能服务的，下面首先看一下在我们构建了所有的数据结构以后，获得的最终结构的图像：</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 23-06-02屏幕截图.png" alt="2018-08-04 23-06-02屏幕截图"></p>
<p>分别解说：</p>
<ol>
<li>在左侧红白相间的是<strong>哈希表</strong>结构，<strong>哈希表</strong>的是一串具有连续地址的数组，每一个地址当中存了一个空的哈希表节点(包含<strong>双向列表</strong>)。在它的后面使用<strong>哈希节点</strong>存储了车辆的信息，每一个节点是一个车辆，<strong>哈希节点</strong>之间使用<strong>双向列表</strong>链接。那么我们是怎么确定一个车辆的信息是挂载在哪个节点上的呢？就是对车辆ID进行求余，例如对第1辆车的ID求余以后得到了1，我们就把它挂载在第一个哈希节点上。</li>
<li>右下角的网格就是我们的地图，由于我们将二维的网格降维了，所以二维的网格也是通过一组地址连续的一维数组存储的。每一个网格里面存储了<strong>双向列表</strong>的一个头结点，后面挂载在了这个网格当中的车辆的节点。</li>
<li>我们想要查找一个网格里的车辆信息，只需要找到网格，对网格里的<strong>双向列表节点</strong>进行遍历即可。</li>
<li>我们想要查找一个车辆在哪个网格里，只需要对该车辆的id<strong>求余</strong>，找到对应的<strong>哈希表节点</strong>，再对后面的哈希节点遍历即可。</li>
</ol>
<p>下面就是我们代码部分了。</p>
<h3 id="5-2-存储节点结构设计"><a href="#5-2-存储节点结构设计" class="headerlink" title="5.2 存储节点结构设计"></a>5.2 存储节点结构设计</h3><p>存储节点用来存储查询到的车辆信息。其结构与之前定义的<code>lbs_mov_node</code>相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_index.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_res_node_s</span> &#123;</span></span><br><span class="line">  <span class="keyword">lbs_queue_t</span> <span class="built_in">queue</span>;   <span class="comment">// 返回结果的链表</span></span><br><span class="line">  <span class="keyword">double</span>   lon;        <span class="comment">// 纬度</span></span><br><span class="line">  <span class="keyword">double</span>   lat;        <span class="comment">// 经度</span></span><br><span class="line">  <span class="keyword">uint32_t</span> id;         <span class="comment">// 出租车唯一ID号</span></span><br><span class="line">  <span class="keyword">uint64_t</span> timestamp;  <span class="comment">// 时间戳</span></span><br><span class="line">&#125; <span class="keyword">lbs_res_node_t</span>;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-定义索引方法"><a href="#5-3-定义索引方法" class="headerlink" title="5.3 定义索引方法"></a>5.3 定义索引方法</h3><p>由于在range_query和knn_query都是在同一个<code>.cpp</code>文件当中声明的，所以最后一个<code>lbs_grid_index_nn_query()</code>函数在第8部分不再单独声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_index.h</span></span><br><span class="line"><span class="comment">// 初始化网格索引</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lbs_grid_index_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 更新接口[出租车位置更新]</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lbs_grid_index_update</span><span class="params">(<span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">uint64_t</span> timestamp, <span class="keyword">uint32_t</span> id)</span></span>;</span><br><span class="line"><span class="comment">// 范围查询接口[查询某一范围内的所有出租车信息]</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lbs_grid_index_range_query</span><span class="params">(<span class="keyword">double</span> lon1, <span class="keyword">double</span> lon2, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lat2, <span class="keyword">lbs_res_node_t</span>* out)</span></span>;</span><br><span class="line"><span class="comment">// KNN查询接口[查询离lon,lat最近的出租车]</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lbs_grid_index_nn_query</span><span class="params">(<span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">lbs_res_node_t</span>* out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lbs_index.h终止</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-初始化网格索引"><a href="#5-4-初始化网格索引" class="headerlink" title="5.4 初始化网格索引"></a>5.4 初始化网格索引</h3><p>方法同初始化网格，只是提供一个接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_index.cpp</span></span><br><span class="line"><span class="comment">// 初始化网格索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_index_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = lbs_grid_init(&amp;lbs_grid, LBS_LON_MIN, LBS_LON_MAX, LBS_LAT_MIN, LBS_LAT_MAX, LBS_ROW_NUM, LBS_COL_NUM);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="5-5-定义网格更新接口"><a href="#5-5-定义网格更新接口" class="headerlink" title="5.5 定义网格更新接口"></a>5.5 定义网格更新接口</h3><p>也在网格更新当中书写过了，直接调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_index.cpp</span></span><br><span class="line"><span class="comment">// 更新接口[出租车位置更新]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_index_update</span><span class="params">(<span class="keyword">double</span> lon,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">double</span> lat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">uint64_t</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">uint32_t</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = lbs_grid_update(&amp;lbs_grid, lon, lat, timestamp, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="5-6-实现range-query函数"><a href="#5-6-实现range-query函数" class="headerlink" title="5.6 实现range_query函数"></a>5.6 实现range_query函数</h3><p>重温一下range_query的功能，range_query是可以显示一个屏幕显示范围内的全部车辆信息，我们要解决两个问题：</p>
<ul>
<li>如何快？最快的方法当然是遍历，但效率很低，我们写这些数据结构就是为了让查找更快的。</li>
<li>对于一个只有半个格子在屏幕中的格子我们如何处理。</li>
</ul>
<p>对此，我们实现range_query的步骤如下：</p>
<p><strong>step1</strong> 我们得到屏幕四个角的经纬度，分别为<code>lat1</code>,<code>lat2</code>, <code>lon1</code>, <code>lon2</code>。</p>
<p><strong>step2</strong> 分别找出四个角对应的<code>cell_id</code>。</p>
<p><strong>step3</strong> 对每一个格子里的每一个车辆节点进行遍历，判断是否在格子内。</p>
<p><strong>step4</strong> 在格子内的话就存入我们之前定义的<code>lbs_res_node</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上lbs_index.cpp</span></span><br><span class="line"><span class="comment">// 范围查询接口[查询某一范围内的所有出租车信息]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_index_range_query</span><span class="params">(<span class="keyword">double</span> lon1,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">double</span> lon2,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">double</span> lat1,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">double</span> lat2,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">lbs_res_node_t</span>* out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = lbs_grid_cell_row(&amp;lbs_grid, lat1);</span><br><span class="line">  <span class="keyword">int</span> col1 = lbs_grid_cell_col(&amp;lbs_grid, lon1);</span><br><span class="line">  <span class="keyword">int</span> row2 = lbs_grid_cell_row(&amp;lbs_grid, lat2);</span><br><span class="line">  <span class="keyword">int</span> col2 = lbs_grid_cell_row(&amp;lbs_grid, lon2);</span><br><span class="line">  <span class="comment">//对每一个格子进行遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row1; i &lt; row2; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = col1; j &lt; col2; j ++)&#123;</span><br><span class="line">      <span class="keyword">int</span> cell_id = lbs_grid_cell_id(&amp;lbs_grid, i, j);</span><br><span class="line">      <span class="comment">//找到id对应的cell的地址</span></span><br><span class="line">      <span class="keyword">lbs_cell_t</span>* lbs_cell = lbs_grid_cell(&amp;lbs_grid, cell_id);</span><br><span class="line">      <span class="comment">//对该cell里的双向列表进行遍历</span></span><br><span class="line">      <span class="keyword">lbs_mov_node_t</span>* headnode = (lbs_mov_node* )&amp;(lbs_cell-&gt;dammy_node.<span class="built_in">queue</span>);</span><br><span class="line">      <span class="keyword">lbs_mov_node_t</span>* currnode = (lbs_mov_node* )&amp;(lbs_cell-&gt;dammy_node.<span class="built_in">queue</span>.next);</span><br><span class="line">      <span class="keyword">while</span>(currnode != headnode)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((currnode-&gt;lon &lt;= lon2) &amp;&amp; (currnode-&gt;lon &gt;= lon1) &amp;&amp; (currnode-&gt;lat &gt;= lat1) &amp;&amp; (currnode-&gt;lat &lt;= lat2))&#123;</span><br><span class="line">          <span class="keyword">lbs_res_node_t</span>* currnode_cloned = (lbs_mov_node* )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">lbs_mov_node_t</span>));</span><br><span class="line">          <span class="built_in">memcpy</span>(currnode_cloned, currnode, <span class="keyword">sizeof</span>(<span class="keyword">lbs_res_node_t</span>));</span><br><span class="line">          lbs_queue_insert_head(&amp;(out-&gt;<span class="built_in">queue</span>), &amp;(currnode_cloned-&gt;<span class="built_in">queue</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        currnode = (<span class="keyword">lbs_mov_node_t</span>* )currnode-&gt;<span class="built_in">queue</span>.next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见第8部分</span></span><br></pre></td></tr></table></figure>
<h2 id="6-Bitmap数据结构"><a href="#6-Bitmap数据结构" class="headerlink" title="6. Bitmap数据结构"></a>6. Bitmap数据结构</h2><p><strong>BItmap</strong>是一个常用的数据结构，常常用来表示在一个连续的编号体系当中，哪些编号对应的物理内存已经被占用，哪些没有，使用相当的高效。</p>
<h3 id="6-1-Bitmap算法原理"><a href="#6-1-Bitmap算法原理" class="headerlink" title="6.1 Bitmap算法原理"></a>6.1 Bitmap算法原理</h3><p>Bitmap是以位(Bit)作为基本的操作单位，一个位只有0和1两种状态。而我们指导计算机的基本存储单位是字节(Byte)，一个(Byte)中有8个位，因此我们想要对位进行基本操作，仅靠传统的加减乘除是不肯能的，只能通过<strong>位操作</strong>来进行。相关的位运算记录在了基础知识这一章中。</p>
<p><strong>提出问题:</strong>  我们现在有一组<strong>连续的</strong>内存地址用来存储网格cell的id，假设我们有id 1, 2, 3, 4, 5, 6, 7, 8, 9, 10，再假设我们需要按照<strong>一定的规则对每个cell进行一次遍历</strong>，可是<strong>该规则会多次涉及到已经遍历过的cell</strong>，问如何使用一种最快速，最节省内存的方法保存<strong>已经遍历过的id</strong>和<strong>未遍历的id</strong>?</p>
<p><strong>解决方案</strong>:</p>
<p>首先我们分配出来16个bit位均初始化为0。为什么不是10个？因为电脑的存储的最小单位是Byte，<code>1Byte = 8bits</code>，所以我们只能取到8的倍数。</p>
<p>​                                  <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code>    |     <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code></p>
<p>假设我们第一次迭代需要检查1, 2, 3, 在检查过这三个之后我们后面就再也不需要检查了，此时每一个位均为0，因此我们将前三位设置为1。</p>
<p>​                                  <code>1</code> <code>1</code> <code>1</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code>    |     <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code></p>
<p>假设我们第一次迭代需要检查3, 5, 6, 此时3我们已经检查过了，不需要再次检查，因此我们将5与6设置为1。在这里我们需要定义一个<strong>检查某一位是否为1的函数</strong>。</p>
<p>如此迭代往复，直到前10位都是1为止。</p>
<p>​                                  <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code>    |     <code>1</code> <code>1</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code></p>
<p>由此可见，Bitmap适用于非重复整形数组的一些问题，常用于<strong>数组的排序</strong>以及<strong>存储地址是否为空</strong>的判断等。</p>
<h3 id="6-2-Bitmap结构设计"><a href="#6-2-Bitmap结构设计" class="headerlink" title="6.2 Bitmap结构设计"></a>6.2 Bitmap结构设计</h3><p>这里我们熟悉一些简单的变量结构体(这些结构体是type类型的，但不是基本数据类型，由于公认和使用方便而被定义):</p>
<ul>
<li>uint8_t为结构体，原结构unsigned char</li>
<li>uint16_t为结构体，原结构unsigned short int</li>
<li>uint32_t为结构体，原结构unsighned int</li>
<li>uint64_t为结构体，原结构unsigned long int</li>
</ul>
<p>由于在C语言当中可以声明的最小变量是char类型(uint8_t)，所以这里我们使用char(uint8_t)类型来完成Bitmap数据结构的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_bitmap.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_bitmap_s</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> *bits;</span><br><span class="line">        <span class="keyword">uint32_t</span> bits_num;</span><br><span class="line">&#125; <span class="keyword">lbs_bitmap_t</span>;</span><br><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_init</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> bits_num)</span></span>;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_destroy</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap)</span></span>;</span><br><span class="line"><span class="comment">//设置pos位为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_setbit</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//设置pos位为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_unsetbit</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//判断pos位是否为1，为1返回1，为0返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_isset</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//结束lbs_bitmap.h</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3Bitmap的初始化"><a href="#6-3Bitmap的初始化" class="headerlink" title="6.3Bitmap的初始化"></a>6.3Bitmap的初始化</h3><ul>
<li>根据参数<code>bitnum</code>计算出我们需要声明多少个uint8_t变量</li>
<li>以<code>bits</code>作为首地址，分配这些uint8_t变量</li>
<li>均初始化为0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_init</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> bits_num)</span></span>&#123;</span><br><span class="line">  lbs_bitmap-&gt;bits_num = bits_num;</span><br><span class="line">  <span class="keyword">int</span> uint8_num = bits_num / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">  lbs_bitmap-&gt;bits = (<span class="keyword">uint8_t</span>* )<span class="built_in">calloc</span>(uint8_num, <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>) );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i == uint8_num; i++)&#123;</span><br><span class="line">    lbs_bitmap-&gt;bits[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-Bitmap的析构函数"><a href="#6-4-Bitmap的析构函数" class="headerlink" title="6.4 Bitmap的析构函数"></a>6.4 Bitmap的析构函数</h3><p>其实只要析构头地址就可以了…这里我写错了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_destroy</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = lbs_bitmap-&gt;bit_num; i == <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="built_in">free</span>(lbs_bitmap-&gt;bits + i)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="6-5-Bitmap设置位1"><a href="#6-5-Bitmap设置位1" class="headerlink" title="6.5 Bitmap设置位1"></a>6.5 Bitmap设置位1</h3><ul>
<li>找到pos是在第几个字节</li>
<li>找到pos是在该字节的哪个位</li>
<li>定义一个<code>mask</code>字节，将pos位设置为1</li>
<li>进行<strong>或</strong>运算</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_setbit</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_index = pos / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> bit_index = pos % <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_mask = (<span class="number">1</span> &lt;&lt; (<span class="number">8</span>-bit_index<span class="number">-1</span>));</span><br><span class="line">  lbs_bitmap-&gt;bits[byte_index] |= byte_mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="6-5-Bitmap设置位0"><a href="#6-5-Bitmap设置位0" class="headerlink" title="6.5 Bitmap设置位0"></a>6.5 Bitmap设置位0</h3><ul>
<li>找到pos是在第几个字节</li>
<li>找到pos是在该字节的哪个位</li>
<li>定义一个<code>mask</code>字节，将pos位设置为0</li>
<li>进行<strong>与</strong>运算</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_unsetbit</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_index = pos / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> bit_index = pos % <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_mask = ~(<span class="number">1</span> &lt;&lt; (<span class="number">8</span>-bit_index<span class="number">-1</span>));</span><br><span class="line">  lbs_bitmap-&gt;bits[byte_index] &amp;= byte_mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="6-5-Bitmap某位是否设置"><a href="#6-5-Bitmap某位是否设置" class="headerlink" title="6.5 Bitmap某位是否设置"></a>6.5 Bitmap某位是否设置</h3><ul>
<li>找到pos是在第几个字节</li>
<li>找到pos是在该字节的哪个位</li>
<li>定义一个<code>mask</code>字节，将pos位设置为1</li>
<li>进行<strong>与</strong>运算</li>
<li>判断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_isset</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_index = pos / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> bit_index = pos % <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_mask = (<span class="number">1</span> &lt;&lt; (<span class="number">8</span>-bit_index));</span><br><span class="line">  lbs_bitmap-&gt;bits[byte_index] &amp;= byte_mask;</span><br><span class="line">  <span class="keyword">if</span> (lbs_bitmap-&gt;bits[byte_index] == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>    </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终止lbs_bitmap.cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="7-堆数据结构"><a href="#7-堆数据结构" class="headerlink" title="7.堆数据结构"></a>7.堆数据结构</h2><h3 id="7-1-堆的原理"><a href="#7-1-堆的原理" class="headerlink" title="7.1 堆的原理"></a>7.1 堆的原理</h3><p><strong>什么是堆:</strong></p>
<p>堆是满足下列性质的数据序列{r1, r2 , …,rn }<br>$$<br>\left{ \begin{array}{ll}<br>r_{2i} \ge r_i &amp;\<br>r_{2i+1}\ge r_i&amp;<br>\end{array} \right.(Min Heap)<br>$$<br>或者<br>$$<br>\left{ \begin{array}{ll}<br>r_{2i} \le r_i &amp;\<br>r_{2i+1}\le r_i&amp;<br>\end{array} \right.(Max Heap)<br>$$<br>当一个序列满足这种性质的时候，我们就可以在逻辑上认为它长这样，这样从上到下它就成为了一个堆的形状，可以看到每一个节点的左孩子节点和右孩子节点都要比它的父节点的数值更大，因此这是一个小顶堆:</p>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |</p>
<p>​                                                97</p>
<p><strong>堆的性质</strong></p>
<p>这个时候如果我们想要获得它的最大的元素只需要取得它的有元素即可。</p>
<p>在这里可以看到：</p>
<ul>
<li>对于一个索引是<code>i</code>的父节点(parent)，其左孩子(left child)索引为 <code>2i+1</code></li>
<li>对于一个索引是<code>i</code>的父节点(parent)，其右孩子(left child)索引为 <code>2i+2</code></li>
<li>对于一个索引是<code>i</code>的子节点，它的父节点的索引是 <code>(i - 1) / 2</code></li>
</ul>
<p>关于堆的操作我们在下文中讲。</p>
<h3 id="7-2堆的结构设计"><a href="#7-2堆的结构设计" class="headerlink" title="7.2堆的结构设计"></a>7.2堆的结构设计</h3><p>首先设计每一个堆的节点heapnode，存储以下的信息</p>
<ul>
<li>该节点距离目标点的距离</li>
<li>该节点是否为1个格子，1为是格子，0非格子</li>
<li>该<code>cell</code>的id号</li>
<li>存储一个车辆的节点信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_nnheap.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_heapnode_s</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> distance;</span><br><span class="line">        <span class="keyword">uint8_t</span> is_grid; <span class="comment">// 1是网格 0是移动对象</span></span><br><span class="line">        <span class="keyword">int</span> cell_id;</span><br><span class="line">        <span class="keyword">lbs_mov_node_t</span> *node;</span><br><span class="line">&#125; <span class="keyword">lbs_heapnode_t</span>;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<p>在定义heapnode结构以后，可以利用heapnode来定义heap结构</p>
<ul>
<li>包含它的已经被占用的容量<code>size</code>(开始定义一个数组有很多是空的)</li>
<li>它的容量<code>capacity</code></li>
<li>存储heapnode数据的头地址<code>heap_nodes</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_nnheap_s</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> size;</span><br><span class="line">        <span class="keyword">uint32_t</span> capacity;</span><br><span class="line">        <span class="keyword">lbs_heapnode_t</span> * heap_nodes;</span><br><span class="line">&#125; <span class="keyword">lbs_nnheap_t</span>;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<p>声明堆的方法，包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.h</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_init</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap)</span></span>;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_destroy</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap)</span></span>;</span><br><span class="line"><span class="comment">//插入一个heapnode到堆</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_insert</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap, <span class="keyword">lbs_mov_node_t</span>* lbs_mov_node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> cell_id, <span class="keyword">uint8_t</span> is_grid, <span class="keyword">double</span> distance)</span></span>;</span><br><span class="line"><span class="comment">//获取堆顶heapnode</span></span><br><span class="line"><span class="keyword">lbs_heapnode_t</span> *lbs_nnheap_top(<span class="keyword">lbs_nnheap_t</span> *lbs_nnheap);</span><br><span class="line"><span class="comment">//弹出堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lbs_nnheap_pop</span><span class="params">(<span class="keyword">lbs_nnheap_t</span> *lbs_nnheap)</span></span>;</span><br><span class="line"><span class="comment">//结束lbs_nnheap.h</span></span><br></pre></td></tr></table></figure>
<h3 id="7-3-堆的初始化"><a href="#7-3-堆的初始化" class="headerlink" title="7.3 堆的初始化"></a>7.3 堆的初始化</h3><p>在初始化堆的时候，我们并不知道堆里有多少个节点，所以我们仅仅给它10个<code>heapnode</code>的内存空间。当不够用时再重新分配内存。但刚开始的时候size是0是可以确定的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_nnheap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_init</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap)</span></span>&#123;</span><br><span class="line">  lbs_nnheap-&gt;size = <span class="number">0</span>;</span><br><span class="line">  lbs_nnheap-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">  lbs_nnheap-&gt;heap_nodes = (<span class="keyword">lbs_heapnode_t</span>* )<span class="built_in">calloc</span>(capacity, <span class="keyword">sizeof</span>(<span class="keyword">heap_node_t</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-堆的析构"><a href="#7-4-堆的析构" class="headerlink" title="7.4 堆的析构"></a>7.4 堆的析构</h3><p>这里的析构也知道析构头地址里就可以了，写复杂了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_destroy</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = lbs_nnheap-&gt;capacity; i == <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="built_in">free</span>(lbs_nnheap-&gt;heap_nodes + i)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-将一个heapnode插入堆"><a href="#7-5-将一个heapnode插入堆" class="headerlink" title="7.5 将一个heapnode插入堆"></a>7.5 将一个heapnode插入堆</h3><p>插入堆的算法相应复杂，值得一写。大体可以几个步骤，我们以下面这个堆为例，假设我们需要插入节点31</p>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |</p>
<p>​                                                97</p>
<ul>
<li>step1 将新插入的节点放在堆的末尾</li>
</ul>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |       |</p>
<p>​                                                97     <strong>31</strong></p>
<ul>
<li>step2  将插入的节点与父节点进行对比，也就是和50对比，比50小则互换位置，否则不动</li>
</ul>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    <strong>31</strong>       76    65     49</p>
<p>​                                                 |       |</p>
<p>​                                                97     <strong>50</strong></p>
<ul>
<li>step3 如此迭代，直到到达一个合适的位置结束</li>
</ul>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            <strong>31</strong>          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    <strong>38</strong>       76    65     49</p>
<p>​                                                 |       |</p>
<p>​                                                97     50</p>
<p>下面是插入一个节点的代码实现。注意一下几点：</p>
<ul>
<li>在插入一个新节点的时候，如果超出了<code>nnheap</code>的<code>capacity</code>则需要使用<code>reaclloc</code>指令重新分配内存</li>
<li>这里我们是使用的孩子节点和父节点的数组的秩来进行比较大小和互换位置。</li>
<li>仔细思考秩+1，-1的区别，遍历到每一个节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_insert</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap, <span class="keyword">lbs_mov_node_t</span>* lbs_mov_node,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> cell_id, <span class="keyword">uint8_t</span> is_grid, <span class="keyword">double</span> distance)</span></span>&#123;</span><br><span class="line">  <span class="comment">//新建一个heapnode</span></span><br><span class="line">  <span class="keyword">lbs_heapnode_t</span> new_heapnode;</span><br><span class="line">  new_heapnode.is_grid = is_grid;</span><br><span class="line">  new_heapnode.cell_id = cell_id;</span><br><span class="line">  new_heapnode.node = lbs_mov_node;</span><br><span class="line">  new_heapnode.distance = distance;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//在capacity已经被填满以后，重新分配内存。插入新节点</span></span><br><span class="line">  <span class="keyword">if</span> (lbs_nnheap-&gt;size == lbs_nnheap-&gt;capacity)&#123;</span><br><span class="line">    lbs_nnheap-&gt;heap_nodes = (<span class="keyword">lbs_heapnode_t</span>* )<span class="built_in">realloc</span>(lbs_nnheap-&gt;heap_nodes, <span class="number">2</span>* capacity*(<span class="keyword">sizeof</span>(<span class="keyword">heap_node_t</span>))); </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">int</span> new_node_index = size + <span class="number">1</span>;</span><br><span class="line">  lbs_nnheap-&gt;(heap_nodes + new_node_index) = new_heapnode;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//取出新插入的节点和其父节点的秩，以及一个中间节点</span></span><br><span class="line">  lbs_nnheap-&gt;size++;</span><br><span class="line">  <span class="keyword">int</span> child = lbs_nnheap-&gt;size;</span><br><span class="line">  <span class="keyword">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">lbs_heapnode_t</span> temp_heapnode;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//互换直至插入节点到达正确的位置</span></span><br><span class="line">  <span class="keyword">while</span> (parent_node-&gt;distance &gt; inserted_node-&gt;distance)&#123;</span><br><span class="line">    temp_heapnode = lbs_nnheap-&gt;heap_nodes[child];</span><br><span class="line">    lbs_nnheap-&gt;heap_nodes[child] = lbs_nnheap-&gt;heap_nodes[parent];</span><br><span class="line">    lbs_nnheap-&gt;heap_nodes[parent] = temp_heapnode;</span><br><span class="line">    parent = (parent - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="7-6-获取堆的头结点"><a href="#7-6-获取堆的头结点" class="headerlink" title="7.6 获取堆的头结点"></a>7.6 获取堆的头结点</h3><p>返回头地址即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.cpp</span></span><br><span class="line"><span class="keyword">lbs_heapnode_t</span> *lbs_nnheap_top(<span class="keyword">lbs_nnheap_t</span> *lbs_nnheap)&#123;</span><br><span class="line">  <span class="keyword">return</span> lbs_nnheap-&gt;heap_nodes</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="7-7-删除头结点"><a href="#7-7-删除头结点" class="headerlink" title="7.7 删除头结点"></a>7.7 删除头结点</h3><p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |</p>
<p>​                                                97</p>
<p>删除头结点并没有看上去那么简单，首先我们去掉头结点，堆也就变成了下面这种结构(没有了头的堆不应该被称作堆)，所以我们需要通过以下几个步骤重新建堆：</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |</p>
<p>​                                                97</p>
<ul>
<li>step1 将最后一个节点放在头结点上</li>
</ul>
<p>​                                                                  <strong>97</strong></p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<ul>
<li>step2 将<strong>头结点</strong>与其<strong>子节点中较大的一个子节点</strong>比较大小，如果<strong>头结点</strong>大于该<strong>子节点</strong>则位置互换</li>
</ul>
<p>​                                                                  <strong>38</strong></p>
<p>​                                                             |            |</p>
<p>​                                                            <strong>97</strong>          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<ul>
<li>step3 如此往复，直到该头结点到达正确的位置结束</li>
</ul>
<p>​                                                                  38</p>
<p>​                                                             |            |</p>
<p>​                                                            <strong>76</strong>          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       <strong>97</strong>    65     49</p>
<p>下面是该过程的代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lbs_nnheap_pop</span><span class="params">(<span class="keyword">lbs_nnheap_t</span> *lbs_nnheap)</span></span>&#123;</span><br><span class="line">  <span class="comment">//将头结点替换为最后一个节点，并释放最后一个节点的内存</span></span><br><span class="line">  lbs_nnheap-&gt;heap_nodes[<span class="number">0</span>] = lbs_nnheap-&gt;heap_nodes[lbs_nnheap-&gt;size];</span><br><span class="line">  lbs_nnheap-&gt;size--;</span><br><span class="line">  <span class="comment">//free(lbs_nnheap-&gt;heap_nodes + size);数组的空间是连续的，不能一次free掉，链表的内存分配是不连续的所以必须借助一个循环体，不停地释放</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//计算父节点和左右子节点的秩</span></span><br><span class="line">  <span class="keyword">int</span> parent = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> l_child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> r_child = <span class="number">2</span> * parent + <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((l_child &lt; lbs_nnheap-&gt;size) || (r_child &lt; lbs_nnheap-&gt;size)&#123;     </span><br><span class="line">    <span class="comment">//heapify</span></span><br><span class="line">    <span class="keyword">while</span>((lbs_nnheap-&gt;heap_nodes[parent].distance &lt; lbs_nnheap-&gt;heap_nodes[l_child].distance) || (lbs_nnheap-&gt;heap_nodes[parent].distance &lt; lbs_nnheap-&gt;heap_nodes[r_child].distance))&#123;</span><br><span class="line">      <span class="keyword">lbs_heapnode_t</span> temp_heapnode;</span><br><span class="line">      <span class="comment">//当右子节点比较大时</span></span><br><span class="line">      <span class="keyword">if</span> (lbs_nnheap-&gt;heap_nodes[l_child].distance &lt; lbs_nnheap-&gt;heap_nodes[r_child].distance)&#123;</span><br><span class="line">        temp_heapnode = lbs_nnheap-&gt;heap_nodes[r_child];</span><br><span class="line">        lbs_nnheap-&gt;heap_nodes[r_child] = lbs_nnheap-&gt;heap_nodes[parent];</span><br><span class="line">        lbs_nnheap-&gt;heap_nodes[parent] = temp_heapnode;</span><br><span class="line">        parent = r_child;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//当左子节点比较大时  </span></span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        temp_heapnode = lbs_nnheap-&gt;heap_nodes[l_child];</span><br><span class="line">        lbs_nnheap-&gt;heap_nodes[l_child] = lbs_nnheap-&gt;heap_nodes[parent];</span><br><span class="line">        lbs_nnheap-&gt;heap_nodes[parent] = temp_heapnode;</span><br><span class="line">        parent = l_child; </span><br><span class="line">        &#125;</span><br><span class="line">      l_child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">      r_child = <span class="number">2</span> * parent + <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;      </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终止lbs_nnheap.cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="8-实现knn-query"><a href="#8-实现knn-query" class="headerlink" title="8. 实现knn_query"></a>8. 实现knn_query</h2><h3 id="8-1算法原理"><a href="#8-1算法原理" class="headerlink" title="8.1算法原理"></a>8.1算法原理</h3><p>knn_query，就是选择距离最近的k辆车，那么我们的思路是一个什么样的呢，最简单的方法当然是对每一辆车进行遍历，着这样的速度太慢，于是我们可以<strong>借助网格</strong>对<strong>堆数据结构</strong>进行剪枝的处理。</p>
<p>处理之前，因为我们要借助网格剪枝，所以首先需要了解一个MinDist的概念。</p>
<p><strong>MinDist等于点P与O的边界上任意点之间的最小距离。若P在O内，则距离为0</strong></p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 11-12-37屏幕截图.png" alt="2018-08-04 11-12-37屏幕截图"></p>
<p><strong>step1</strong> 在了解这个概念以后，我们就可以最近邻算法的书写了，假设我们的起始地点为q，q点位于Cell01(C0)处</p>
<ul>
<li>我们首先使用C0建一个堆，此时距离为0，此时的堆如下：</li>
</ul>
<p>​                                                                           C0</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 11-15-06屏幕截图.png" alt="2018-08-04 11-15-06屏幕截图"></p>
<p><strong>step2</strong> 弹出堆中的头元素(这里就是C0)，如果是个格子，则遍历C0中的每一辆车插入到堆当中；如果头结点是辆车，则说明我们已经找到最近的车了。此处C0是一个格子，我们删去C0，并将C0当中的两辆车a和b插入到堆当中，此处的堆就成为下面这个结构：</p>
<p>​                                                                           a</p>
<p>​                                                                       |</p>
<p>​                                                                       b</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 21-29-14屏幕截图.png" alt="2018-08-04 21-29-14屏幕截图"></p>
<p><strong>step3</strong> 随后检测C0周围的每一个格子，总共有八个我们将他们命名为C11－C18，计算他们的MinDist，插入堆当中，并将相应的Bitmap位设置为1，下一次再遇到这这些格子就可以不必检查了</p>
<p><strong>注意</strong>：此处由于是第一个格子C0，其周围的8个格子均未被检测，所以可以直接插入，如果在后面需要先在Bitmap中查看是否为1再决定是否插入。</p>
<p>插入后的堆如下图所示:</p>
<p>​                                                                           C12</p>
<p>​                                                                      |            |</p>
<p>​                                                                      a          C14</p>
<p>​                                                                |        |     |        |</p>
<p>​                                                            C15   C11   C13      b</p>
<p>​                                                        |       |     |</p>
<p>​                                                   C17    C16   C18</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 21-29-29屏幕截图.png" alt="2018-08-04 21-29-29屏幕截图"></p>
<p><strong>step4</strong> 重复step2，指导弹出的是一个车辆就是我们想要找到的目标车辆。   </p>
<h3 id="8-2-定义全局变量和函数"><a href="#8-2-定义全局变量和函数" class="headerlink" title="8.2 定义全局变量和函数"></a>8.2 定义全局变量和函数</h3><p>这里主要完成了2个工作</p>
<ul>
<li>定义了多个宏</li>
<li>定义了根据经纬度计算距离的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_distance.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SERVER_GRID_LBS_DISTANCE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_GRID_LBS_DISTANCE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159265</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEG2RAD(degree) (degree * PI) / 180.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EARTH_RADIUS 6378.137</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">lbs_distance</span><span class="params">(<span class="keyword">double</span> lon1, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lon2, <span class="keyword">double</span> lat2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> rad_lat1 = DEG2RAD(lat1);</span><br><span class="line">  <span class="keyword">double</span> rad_lat2 = DEG2RAD(lat2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> a = rad_lat1 - rad_lat2;</span><br><span class="line">  <span class="keyword">double</span> b = DEG2RAD(lon1) - DEG2RAD(lon2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> s = <span class="number">2</span> * <span class="built_in">asin</span>(<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">sin</span>(a / <span class="number">2</span>), <span class="number">2</span>) +</span><br><span class="line">                           <span class="built_in">cos</span>(rad_lat1) * <span class="built_in">cos</span>(rad_lat2) * <span class="built_in">pow</span>(<span class="built_in">sin</span>(b / <span class="number">2</span>), <span class="number">2</span>)));</span><br><span class="line">  s = s * EARTH_RADIUS;</span><br><span class="line">  <span class="keyword">return</span> s * <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-编写MinDist函数"><a href="#8-3-编写MinDist函数" class="headerlink" title="8.3 编写MinDist函数"></a>8.3 编写MinDist函数</h3><p>MinDist的大小根据格子所在源格子的位置有所不同，共有九种情况，以下做了分别的编写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_distance.h</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dist_min</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> src_lon, <span class="keyword">double</span> src_lat, <span class="keyword">int</span> dis_cell_id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> grid_distance;</span><br><span class="line">  <span class="keyword">double</span> des_lon;</span><br><span class="line">  <span class="keyword">double</span> des_lat;</span><br><span class="line">  <span class="keyword">int</span> src_cell_row = lbs_grid_cell_row(lbs_grid, src_lat)</span><br><span class="line">  <span class="keyword">int</span> src_cell_col = lbs_grid_cell_col(lbs_grid, src_lon)</span><br><span class="line">  lbs_grid_cell_row_col(lbs_grid, dis_cell_id, &amp;(<span class="keyword">int</span> des_cell_row), &amp;(<span class="keyword">int</span> des_cell_col));</span><br><span class="line">  <span class="comment">//左上的格子</span></span><br><span class="line">  <span class="keyword">if</span> (des_cell_row &gt; src_cell_row) &amp; (des_cell_col &lt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col + <span class="number">1</span>) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//直上的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row &gt; src_cell_row) &amp; (des_cell_col == src_cell_col)&#123;</span><br><span class="line">    des_lon = src_lon;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//右上的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row &gt; src_cell_row) &amp; (des_cell_col &gt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row) * lbs_grid-&gt;cell_height; </span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//直左的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row == src_cell_row) &amp; (des_cell_col &lt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col + <span class="number">1</span>) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = src_lat;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//直右的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row == src_cell_row) &amp; (des_cell_col &gt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = src_lat;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);    </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//本身的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row == src_cell_row) &amp; (des_cell_col == src_cell_col)&#123;</span><br><span class="line">    grid_distance = <span class="number">0</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//左下的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row &lt; src_cell_row) &amp; (des_cell_col &lt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col + <span class="number">1</span>) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row + <span class="number">1</span>) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);  </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//直下的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row &lt; src_cell_row) &amp; (des_cell_col == src_cell_col)&#123;</span><br><span class="line">    des_lon = src_lon;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row + <span class="number">1</span>) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);   </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//右下的格子</span></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row + <span class="number">1</span>) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);  </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> grid_distance</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束lbs_distance.h</span></span><br></pre></td></tr></table></figure>
<h3 id="8-4-实现knn-query"><a href="#8-4-实现knn-query" class="headerlink" title="8.4 实现knn_query"></a>8.4 实现knn_query</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见第五部分range_query函数,lbs_index.cpp</span></span><br><span class="line"><span class="comment">// NN查询接口[查询离lon,lat最近的出租车]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_index_nn_query</span><span class="params">(<span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">lbs_res_node_t</span>* out)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取第src车所在的位置和网格信息</span></span><br><span class="line">  <span class="keyword">double</span> src_lon = lon;</span><br><span class="line">  <span class="keyword">double</span> src_lat = lat;</span><br><span class="line">  <span class="keyword">int</span> src_cell_row = lbs_grid_cell_row(&amp;(lbs_grid), src_lat);</span><br><span class="line">  <span class="keyword">int</span> src_cell_col = lbs_grid_cell_col(&amp;(lbs_grid), src_lon);</span><br><span class="line">  <span class="keyword">int</span> src_cell_id = lbs_grid_cell_id(&amp;(lbs_grid), src_cell_row, src_cell_col);</span><br><span class="line">  <span class="comment">//初始化bitmap，并将src车所在的cell0记录在bitmap里</span></span><br><span class="line">  <span class="keyword">lbs_bitmap_t</span> lbs_bitmap;</span><br><span class="line">  <span class="keyword">int</span> ret = lbs_bitmap_init(&amp;(lbs_bitmap), (lbs_grid.col_num*lbs_grid.row_num));</span><br><span class="line">  ret = lbs_bitmap_setbit(lbs_bitmap, src_cell_id);</span><br><span class="line">  <span class="comment">//利用C0构建最小堆</span></span><br><span class="line">  lbs_nnheap_init lbs_nnheap;</span><br><span class="line">  ret = lbs_nnheap(&amp;(lbs_nnheap));</span><br><span class="line">  ret = lbs_nnheap_insert(&amp;(lbs_nnheap), )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">lbs_mov_node_t</span> lbs_mov_node;</span><br><span class="line">  <span class="keyword">int</span> is_grid = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">double</span> distance = Dist_min(&amp;(lbs_grid), src_lon, src_lat, src_cell_id);</span><br><span class="line">  ret = lbs_nnheap_insert(&amp;(lbs_nnheap), &amp;(lbs_mov_node), src_cell_id, is_grid, distance);</span><br><span class="line">  <span class="comment">//获取头结点</span></span><br><span class="line">  <span class="keyword">lbs_heapnode_t</span>* nnheap_top = lbs_nnheap_top(lbs_nnheap);</span><br><span class="line">  <span class="keyword">int</span> temp_cell_id = src_cell_id;</span><br><span class="line">  <span class="keyword">while</span>(nnheap_top-&gt;is_grid == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//pop掉为grid的头结点</span></span><br><span class="line">    lbs_nnheap_pop(&amp;(lbs_nnheap));</span><br><span class="line">    <span class="comment">//找到该cell里的所有车辆信息，并且插入到heap</span></span><br><span class="line">    <span class="keyword">lbs_mov_node_t</span>* headnode = (<span class="keyword">lbs_mov_node_t</span>* )&amp;(lbs_grid-&gt;cell[temp_cell_id].dammy_node.<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">lbs_mov_node_t</span>* currnode = (<span class="keyword">lbs_mov_node_t</span>* )&amp;(lbs_grid-&gt;cell[temp_cell_id].dammy_node.<span class="built_in">queue</span>.next);</span><br><span class="line">    <span class="keyword">while</span>(headnode != curnode)&#123;</span><br><span class="line">      distance = lbs_distance(src_lon, src_lat, currnode-&gt;lon, currnode-&gt;lat);</span><br><span class="line">      ret = lbs_nnheap_insert(&amp;(lbs_nnheap), currnode, src_cell_id, is_grid = <span class="number">1</span>, distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出目前格子周围的未被检查的格子的cell_id，存入surrounding_id_arr中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">-1</span>; i == <span class="number">1</span>; i ++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">-1</span>; j == <span class="number">1</span>; j ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> new_cell_id = src_cell_id + (i * LBS_COL_NUM) + j;</span><br><span class="line">        ret = lbs_bitmap_isset(&amp;(lbs_bitmap), new_cell_id);</span><br><span class="line">        <span class="keyword">if</span> ret == <span class="number">0</span>&#123;</span><br><span class="line">          distance = Dist_min(&amp;(lbs_grid), src_lon, src_lat, new_cell_id);</span><br><span class="line">          ret = lbs_nnheap_insert(&amp;(lbs_nnheap), &amp;(lbs_mov_node), new_cell_id, is_grid = <span class="number">1</span>, distance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">continue</span>    </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出headnode</span></span><br><span class="line">    nnheap_top = lbs_nnheap_top(lbs_nnheap);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个out就是list of 符合条件的车</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束lbs_index.cpp</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/05/Liunx服务器基本操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaocheng Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs of Zhaocheng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/05/Liunx服务器基本操作/" itemprop="url">Liunx服务器基本操作.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-05T23:13:06+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在搬瓦工上购买了一台服务器，主要是为了可以科学上网，但正好最近的项目需要在另一个服务器上完成，所以记录一些登录和在远程服务器上的基本操作。</p>
<p><strong>登录</strong></p>
<p>首先是登录，登录使用<code>ssh</code>指令。在这里我还没有分配账户，所以使用超级用户root登录，@后面是我的主机ip地址，属性-p后面主要接我们的服务器端口号，Linux中默认为22。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh root@74.82.203.94 -p 26593</span><br></pre></td></tr></table></figure>
<p>回车后需要你输入该地址的密码，输入后即可进入该服务器的terminal界面。</p>
<p><strong>退出</strong></p>
<p>退出is so easy，just <code>logout</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">logout</span></span><br></pre></td></tr></table></figure>
<p><strong>从网上下载文件</strong></p>
<p>上传和下载文件使用<code>scp</code>指令，<code>scp</code>全拼(secure copy)。使用以下语法，将temp.txt文件从网上服务器的vincent地址下载到本地的vincent地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp root@74.82.203.94:/media/vincent/temp.txt /meida/vincent/</span><br></pre></td></tr></table></figure>
<p><strong>从本地上传文件</strong></p>
<p>只需将上一条指令的两个文件夹倒过来即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /meida/vincent/temp.txt root@74.82.203.94:/media/vincent/</span><br></pre></td></tr></table></figure>
<p><strong>分配一个新的用户</strong></p>
<p>在一个大的服务器下，我们常常需要分配多个用户，以方便多个用户对于这个服务器的访问。为了确保可以工作，首先要切换到超级管理员root下，这里就不多赘述了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ useradd testname <span class="comment">#增加用户</span></span><br><span class="line">$ passwd testname <span class="comment">#为testname设置密码，两次输入</span></span><br><span class="line">输入新的 UNIX 密码： </span><br><span class="line">重新输入新的 UNIX 密码： </span><br><span class="line">passwd：已成功更新密码</span><br></pre></td></tr></table></figure>
<p>这时就有了一个叫testname的用户。</p>
<p><strong>删除一个用户</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ userdel testname</span><br><span class="line">$ rm -rf testname <span class="comment">#清空testname的文件家</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/26/opencv-python车辆识别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaocheng Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs of Zhaocheng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/26/opencv-python车辆识别/" itemprop="url">opencv+python车辆识别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-26T09:07:50+08:00">
                2018-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近要做交通管理和控制课程的实验，提到采集数据时老师说可以用多种方法来实现，因此想到自己编写一个车辆识别的程序。第一个想到的是循环神经网络，但是因为自己在机器学习方面造诣还是很浅的，因此选择了比较传统，也是相关论坛比较多的opencv进行实现，这里选用的级联分类器训练(Cascade Classifier)，一路上很多网上的大神的博客给了很详细的指导，记录下来，希望自己以后可以用到。</p>
<p><strong>参考文献：</strong></p>
<p>haar特征识别算法原理：<a href="https://blog.csdn.net/jing_xin/article/details/17383161" target="_blank" rel="noopener">https://blog.csdn.net/jing_xin/article/details/17383161</a></p>
<p>博主提到了很多有用的资源：<a href="https://blog.csdn.net/u014696921/article/details/69935802" target="_blank" rel="noopener">https://blog.csdn.net/u014696921/article/details/69935802</a></p>
<p>opencv关于Cascade Training的文档：<a href="https://docs.opencv.org/2.4/doc/user_guide/ug_traincascade.html" target="_blank" rel="noopener">https://docs.opencv.org/2.4/doc/user_guide/ug_traincascade.html</a></p>
<p>opencv关于Cascade detect的文档：<a href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html?highlight=haar" target="_blank" rel="noopener">https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html?highlight=haar</a></p>
<p>博主提供了详细的实现过程：<a href="https://blog.csdn.net/zhuangxiaobin/article/details/25476833" target="_blank" rel="noopener">https://blog.csdn.net/zhuangxiaobin/article/details/25476833</a></p>
<p><strong>使用资源：</strong></p>
<p>opencv软件，cv2模块(在python中使用opencv)，python，正负车辆样品集</p>
<h2 id="1-搭建需要在python中使用opencv的环境"><a href="#1-搭建需要在python中使用opencv的环境" class="headerlink" title="1. 搭建需要在python中使用opencv的环境"></a>1. 搭建需要在python中使用opencv的环境</h2><p>本次项目不仅需要在python中设置opencv环境，还需要下载opencv的软件到计算机上。因为cv2模块仅仅提供了一些简单的接口，不能够用来创建分类文件xml文件。具体的内容会在后面提到，因此需要下面两个步骤：</p>
<ul>
<li>step1： 安装opencv-python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<ul>
<li>step2：到官网下载opencv，并记住下载后存储的地址。</li>
</ul>
<p>我的存储路径为<code>D:\Program Files (x86)</code>随后打开路径<code>D:\Program Files (x86)\opencv\build\x64\vc14\bin</code>，可以看到后面我们需要用到的两个exe文件<code>opencv_createsamples.exe</code>，<code>opencv_traincascade.exe</code>分别用来创建正样品集和训练联机分类器，在bin文件中意味着它可以直接被cmd调用。</p>
<h2 id="2-创建正负训练样本集"><a href="#2-创建正负训练样本集" class="headerlink" title="2. 创建正负训练样本集"></a>2. 创建正负训练样本集</h2><h3 id="2-1-创建正样本集"><a href="#2-1-创建正样本集" class="headerlink" title="2.1 创建正样本集"></a>2.1 创建正样本集</h3><p><strong>step1：准备数据集</strong></p>
<p>正样本集可以从网上下载训练的开源数据，数据在前面的参考博客中已经给出，也可以在网上查找一些网友自己做的数据集，正样品应当尽量只包含目标物体，尽量减少周围环境的介入。如果非要自己做的话，可以使用<code>objectmarker.exe</code>一个网上可以下载到的程序，可以在我的github网页上下载，不过相对比较麻烦。注意无论是从网上找到的数据集还是自己创建都尽量创建比例较为近似的图片，以便后面做归一化处理。以下是我选择的数据集：</p>
<p>注：在未处理以前有很多jpg文件，转化方法可以在该文件夹中创建一个.txt文件，其中输入<code>ren *.jpg *.bmp</code>后将后缀改为.bat(cmd的代码)，点击运行即可将文件夹中的每一个图片修改为.bmp格式。</p>
<p><img src="/2018/06/26/opencv-python车辆识别/img/TIM截图20180608210759.png" alt="TIM截图20180608210759"></p>
<p><strong>step2：归一化处理</strong></p>
<p>随后我们需要对数据集中的数据做归一化处理，并且转化为灰度图片，该过程的python代码如下。因为将图片缩小有利于训练的效率，因此将宽和高均设置为25(opencv本身的数据集为24)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> os.path  </span><br><span class="line"><span class="keyword">import</span> glob  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertjpg</span><span class="params">(jpgfile,outdir,width=<span class="number">25</span>,height=<span class="number">25</span>)</span>:</span>  </span><br><span class="line">    print(jpgfile)</span><br><span class="line">    img=Image.open(jpgfile)</span><br><span class="line">    print(img)</span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        new_imgt = img.resize((width, height), Image.BILINEAR)</span><br><span class="line">        new_img = new_imgt.convert(<span class="string">'L'</span>)</span><br><span class="line">        print(new_img)</span><br><span class="line">        new_img.save(os.path.join(outdir, os.path.basename(jpgfile)))  </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">        print(e)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> jpgfile <span class="keyword">in</span> glob.glob(<span class="string">"D:/anaconda/gpsdata/*.bmp"</span>):  </span><br><span class="line">    convertjpg(jpgfile,<span class="string">"D:/anaconda/gpsdata1"</span>)</span><br></pre></td></tr></table></figure>
<p>归一化后的图片如下图所示：</p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180608210816.png" alt="TIM截图20180608210816"></p>
<p><strong>step3：创建正样品描述vec文件</strong></p>
<p>我的归一化正样品的储存目录为<code>D:/anaconda/gpsdata1</code>因此在该文件夹下，<code>shift+右键</code>-&gt;<code>在此处打开命令窗口</code>打开cmd后输入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\anaconda\gpsdata1</span><br><span class="line">dir/s/b&gt;pos.txt</span><br></pre></td></tr></table></figure>
<p>即可在文件夹中得到一个pos.txt样本描述文件，文件记录了目录中的每一个图片的目录和文件名。具体样式如下图所示，虽然这还不是我们想要的格式，注意查看最后一行是不是图片还是txt文件本身：</p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180608212139.png" alt="TIM截图20180608212139"></p>
<p>这一步是比较特殊的，因为我的每一个图片大小相等且大小为25才可以这样做。对于一些图片大小非正方形或者大小大于30的慎用。随后我们将这个描述文件复制粘贴到word软件中，使用查找替换功能将每一行替换为如下图的格式，格式从左到右分别描述了表中的属性(此处宽和高均为30其实没有必要，因为图片大小只有25…)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">图片相对路径</th>
<th style="text-align:center">兴趣矩形个数</th>
<th style="text-align:center">矩形左坐标</th>
<th style="text-align:center">矩形上坐标</th>
<th style="text-align:center">矩形宽度</th>
<th style="text-align:center">矩形高度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">gpsdata1\1039284.bmp</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">30</td>
<td style="text-align:center">30</td>
</tr>
</tbody>
</table>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180608212706.png" alt="TIM截图20180608212706"></p>
<h3 id="2-2-创建负样本集"><a href="#2-2-创建负样本集" class="headerlink" title="2.2 创建负样本集"></a>2.2 创建负样本集</h3><p>创建负样本比创建正样本简单很多，但需要比正样本大很多的样本量，因为在视频/图片当中不是目标物体的实际上是比较多的。负样品的内容应该多是道路上非车辆的物体，例如行人、建筑物等，火星、外太空啥的就算了。以下是我从网上下载的负样品：</p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180609080723.png" alt="TIM截图20180609080723"></p>
<p>通过和正样本相同的处理方法，首先将图片转化为bmp文件，在缩小并转化为黑白的图片(此处应按比例转化，并且保证比处理后的大小比正样品大即可)：</p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180609081342.png" alt="TIM截图20180609081342"></p>
<p>同样创建一个描述文件(方法和创建正样品是step 3第一步的方法一样)，创建后如图：</p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180609081806.png" alt="TIM截图20180609081806"></p>
<h3 id="2-3-生成vec文件"><a href="#2-3-生成vec文件" class="headerlink" title="2.3 生成vec文件"></a>2.3 生成vec文件</h3><p>vec文件是opencv中用来描述图片的矩阵文件，就是将可视的图片转化为矩阵存储。下面分步骤完成。</p>
<ul>
<li><strong>step1 创建需要的环境</strong></li>
</ul>
<p>首先将正负样本及其描述文件，最开始文中提到的<code>opencv_createsamples.exe</code>文件放在一个文件夹下(很重要！)，如下图所示(忽视那个bat文件，下文会讲到)：</p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180610171937.png" alt="TIM截图20180610171937"></p>
<p>修改正负样本描述文件的相对路径，使其指向各自的文件夹，这一步可以在很久以前完成…但自己走了一波弯路…还是在word中使用查找替换。替换后的文件如图所示：</p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180610172713.png" alt="TIM截图20180610172713"></p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180610172832.png" alt="TIM截图20180610172832"></p>
<ul>
<li><strong>step2 编写创建vec的bat指令</strong></li>
</ul>
<p>这就是我们上文提到的bat文件了，在该文件夹下新建一个txt文件，写下如下指令，不同的参数可以自己调整：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-info 描述文件 -vec vec文件名 -num正样本数量 -h-w分别为样本高宽</span></span><br><span class="line">opencv_createsamples.exe -info pos.txt -vec pos.vec -num 762 -h 24 -w 24</span><br></pre></td></tr></table></figure>
<p>修改后缀为.bat并且运行就得到一个vec文件。</p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180610173859.png" alt="TIM截图20180610173859"></p>
<p>至此，准备工作结束，下面就是训练样品了。</p>
<h2 id="3-使用adaboost算法训练数据"><a href="#3-使用adaboost算法训练数据" class="headerlink" title="3. 使用adaboost算法训练数据"></a>3. 使用adaboost算法训练数据</h2><p>首先我们在现在的文件夹中新建一个文件夹，命名为cascade_data，其中存储训练后的XML文件数据。然后将文中开头提到的<code>opencv_traincascade.exe</code>放入我们的现在的文件夹。再编写一个我们训练模型用的classify.bat文件，文件的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bg背景描述文件，</span></span><br><span class="line">opencv_traincascade.exe -data data -vec pos.vec -<span class="built_in">bg</span> neg.txt -numPos 762 -numNeg 7708 -numStages 18 -w 24 -h 24 -minHitRate 0.9999 -maxFalseAlarmRate 0.5 -mode ALL</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>文件夹中的文件有以下几个：</p>
<p><img src="/2018/06/26/opencv-python车辆识别/E:/学海无涯\实验\视频数车\实验图片\TIM截图20180610183242.png" alt="TIM截图20180610183242"></p>
<p>点击classify.bat文件就可以开始训练了，我从下午6.30开始训练，训练到</p>
<h2 id="4-对图片进行初步检测"><a href="#4-对图片进行初步检测" class="headerlink" title="4.对图片进行初步检测"></a>4.对图片进行初步检测</h2><h2 id="5-使用cv2做视频处理"><a href="#5-使用cv2做视频处理" class="headerlink" title="5.使用cv2做视频处理"></a>5.使用cv2做视频处理</h2><ul>
<li><strong>step1 使用XML文件对cv2的联机分类器进行标定</strong></li>
</ul>
<p>这一部分的语法可以参考上面的关于cascade_detection的参考文献，其中有较为详细的语法。我们需要拿我们在上一步训练得到的XML文件首先对识别器进行标定。语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car_cascade = cv2.CascadeClassifier(<span class="string">'haarcascade_frontalface_default.xml'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>step2 创建截取和写入视频的对象</strong></li>
</ul>
<p>首先我们知道视频是由一帧帧的图片组成的，衡量的单位为FPS(Frame Per Second)，我们首先导入cv2并且创建视频截取的对象。它的参数可以是设备索引，也可以是要读取的视频文件的名称。</p>
<p>在大多数情况下，只有一台摄像机连接到系统。 所以，我们所做的只是传递’0’，OpenCV使用连接到计算机的唯一相机。 当多台摄像机连接到电脑时，我们可以通过’1’来选择第二台摄像机，通过’2’来选择第三台摄像机，等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个视频截取对象和一个视频存储对象</span></span><br><span class="line"><span class="comment"># 如果视频是通过计算机的摄像头识别的，则传入0，这里传入我们录制的车辆视频</span></span><br><span class="line"></span><br><span class="line">fps = <span class="number">24</span>   <span class="comment">#视频帧率</span></span><br><span class="line">fourcc = cv2.cv.CV_FOURCC(<span class="string">'M'</span>,<span class="string">'J'</span>,<span class="string">'P'</span>,<span class="string">'G'</span>) </span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">'chaplin.mp4'</span>)</span><br><span class="line">videoWriter = cv2.VideoWriter(<span class="string">'D:/testResults/match/flower2.avi'</span>, fourcc, fps, (<span class="number">1360</span>,<span class="number">480</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>step3 逐帧处理并写入视频</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> moviepy.editor <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment">#from cv2 import cv</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">'E:/学海无涯/20180613_IMG_0627 (3).MOV'</span></span><br><span class="line">fps = <span class="number">24</span>   <span class="comment">#视频帧率</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'XVID'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#clip = VideoFileClip(filename).subclip(242,291)</span></span><br><span class="line"><span class="comment">#clip.write_videofile("E:/学海无涯/rawvideo.mp4")</span></span><br><span class="line"></span><br><span class="line">car_cascade = cv2.CascadeClassifier(<span class="string">'C:/Users/Administrator/Desktop/lll/haarcascade_eye.xml'</span>)</span><br><span class="line">car_cascade.load(<span class="string">'C:/Users/Administrator/Desktop/lll/haarcascade_eye.xml'</span>)</span><br><span class="line">VideoCap = cv2.VideoCapture(<span class="string">"E:/学海无涯/rawvideo.mp4"</span>)</span><br><span class="line">videoWriter = cv2.VideoWriter(<span class="string">'E:/学海无涯/processedvideo.mp4'</span>, fourcc, fps, (<span class="number">1360</span>,<span class="number">480</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(VideoCap.isOpened()):</span><br><span class="line">  ret, frame = VideoCap.read() <span class="comment">#逐帧获取视频，frame是图片</span></span><br><span class="line">  <span class="keyword">if</span> ret == <span class="keyword">True</span>: <span class="comment">#处理并显示这一帧的图片</span></span><br><span class="line">      gray_img = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) <span class="comment">#转化为灰度图</span></span><br><span class="line">      cars = car_cascade.detectMultiScale(gray_img, <span class="number">1.3</span>, <span class="number">5</span>) <span class="comment">#车辆检测，返回(x,y,w,h)</span></span><br><span class="line">      <span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> cars: <span class="comment">#对每一个兴趣区画框</span></span><br><span class="line">        	cv2.rectangle(frame,(x,y),(x+w,y+h),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">      cv2.imshow(<span class="string">'Frame'</span>,frame) <span class="comment">#显示图片</span></span><br><span class="line">      videoWriter.write(frame)</span><br><span class="line">      <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>): <span class="comment">#按Q停止</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">else</span>: <span class="comment">#没有帧后显示循环</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#处理完后释放所有的对象</span></span><br><span class="line">VideoCap.release()</span><br><span class="line">videoWriter.release()</span><br><span class="line"><span class="comment">#关闭所有帧</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>在做完了这一波之后越来越觉得掌握算法本身比掌握如何使用算法更加的重要，相比而言现在的东西还是一个半成品，代码什么的后面还需要改进。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/01/交通向参考文献和检索方法汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaocheng Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs of Zhaocheng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/交通向参考文献和检索方法汇总/" itemprop="url">交通向参考文献和检索方法汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-01T12:14:35+08:00">
                2018-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="参考文献和检索方法汇总"><a href="#参考文献和检索方法汇总" class="headerlink" title="参考文献和检索方法汇总"></a>参考文献和检索方法汇总</h1><p>最近听了很多也问了很多关于信息检索的方法，信息检索的网站以及相关期刊的问题，做一下简单的整理。因为倩妮老铁在之前已经做了一波整理，因此在这里做一波cite。有兴趣的可以通过下面的网页参考并且关注倩妮老铁的博客。</p>
<p><strong>参考内容 ：</strong></p>
<p>倩妮老铁的博客: <a href="http://qianni1997.github.io/" target="_blank" rel="noopener">http://qianni1997.github.io/</a></p>
<p>陈喜群老师个人主页: <a href="http://person.zju.edu.cn/xiqun/687353.html" target="_blank" rel="noopener">http://person.zju.edu.cn/xiqun/687353.html</a></p>
<h2 id="信息检索的常用网页："><a href="#信息检索的常用网页：" class="headerlink" title="信息检索的常用网页："></a>信息检索的常用网页：</h2><ul>
<li><p>百度学术或者在百度主页的右上角设置上进行高级检索</p>
<p>虽然百度学术的质量不高，但有一点好处是在找到想要引用的文章之后，在左侧可自动生成引用论文的格式。</p>
</li>
<li><p>中国知网(CNKI)</p>
<p>这个就不必多说了，注意常看的论文类型为硕博士论文和期刊论文。</p>
</li>
<li><p>Web of science</p>
<p>可以从交大图书馆主页的热门资源中进入，如果自己进入的话需要进行账号登录。主要为SCI数据库。但由于论文发表后需要有一段时间的延迟方可在该网页上找到资源，信息更新相对较慢。</p>
</li>
<li><p>Science Direct </p>
<p>就不多说了，收录论文相当全面，能够覆盖大量的期刊，并且可以在校园网的环境下下载。</p>
</li>
<li><p>Google scholar</p>
<p>覆盖面优于Science direct，但由于需要翻墙加上学校并没有购买使用权，可以在出国后使用。</p>
</li>
</ul>
<h2 id="交通领域的重要外文期刊"><a href="#交通领域的重要外文期刊" class="headerlink" title="交通领域的重要外文期刊"></a>交通领域的重要外文期刊</h2><p>以下期刊是在郑芳芳老师课后提及的几个期刊，由倩妮老铁整理，包含但不限于：</p>
<ul>
<li><p>《Transportation Science》</p>
</li>
<li><p>《Transportation Research》</p>
<p>A: Policy and Practice; B: Methodological; C: Emerging technology; </p>
<p>D: Transport and environment; E: Logistics and Transportation; F: Traffic psychology and behaviors</p>
</li>
<li><p>《IEEE Xplore: IEEE Transaction on Intelligent Transportation System》</p>
<p>此期刊偏向于应用</p>
</li>
<li><p>ISTTT—International Symposium on Transportation and Traffic Theory</p>
</li>
<li><p>《Journal of Advanced Transportation》</p>
</li>
<li><p>TRB会议</p>
</li>
</ul>
<p>以下为陈喜群老师总结的年度科学与技术领域 SCI 和 SSCI 相关内容，具体参见陈喜群老师主页。自左至右各列分别为序号，期刊名称，影响因子(总引用数除以论文数)，可引用项目(论文发表总数)，被引总数。 </p>
<table>
<thead>
<tr>
<th></th>
<th>Journal Title</th>
<th>Impact Factor</th>
<th>Citable Items</th>
<th>Total Citations</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.</td>
<td>Computer-Aided Civil and Infrastructure Engineering</td>
<td>5.786</td>
<td>60</td>
<td>2444</td>
</tr>
<tr>
<td>2.</td>
<td>Vehicular Communications</td>
<td>5.108</td>
<td>19</td>
<td>202</td>
</tr>
<tr>
<td>3.</td>
<td>IEEE Vehicular Technology Magazine</td>
<td>4.429</td>
<td>25</td>
<td>849</td>
</tr>
<tr>
<td>4.</td>
<td>IEEE Transactions on Vehicular Technology</td>
<td>4.066</td>
<td>894</td>
<td>17010</td>
</tr>
<tr>
<td>5.</td>
<td>Transportation Research Part C-Emerging Technologies</td>
<td>3.805</td>
<td>229</td>
<td>6122</td>
</tr>
<tr>
<td>6.</td>
<td>Transportation Research Part B-Methodological</td>
<td>3.769</td>
<td>194</td>
<td>8518</td>
</tr>
<tr>
<td>7.</td>
<td>IEEE Transactions on Intelligent Transportation Systems</td>
<td>3.724</td>
<td>306</td>
<td>7224</td>
</tr>
<tr>
<td>8.</td>
<td>IEEE Intelligent Transportation Systems Magazine</td>
<td>3.654</td>
<td>27</td>
<td>384</td>
</tr>
<tr>
<td>9.</td>
<td>Transportation Science</td>
<td>3.275</td>
<td>81</td>
<td>4456</td>
</tr>
<tr>
<td>10.</td>
<td>Transportation Research Part E-Logistics and Transportation Review</td>
<td>2.974</td>
<td>155</td>
<td>4427</td>
</tr>
<tr>
<td>11.</td>
<td>Accident Analysis and Prevention</td>
<td>2.685</td>
<td>296</td>
<td>13131</td>
</tr>
<tr>
<td>12.</td>
<td>Journal of Transport Geography</td>
<td>2.675</td>
<td>162</td>
<td>4692</td>
</tr>
<tr>
<td>13.</td>
<td>Networks &amp; Spatial Economics</td>
<td>2.662</td>
<td>49</td>
<td>1041</td>
</tr>
<tr>
<td>14.</td>
<td>Transportation</td>
<td>2.633</td>
<td>51</td>
<td>2692</td>
</tr>
<tr>
<td>15.</td>
<td>Transportation Research Part A-Policy and Practice</td>
<td>2.609</td>
<td>201</td>
<td>6615</td>
</tr>
<tr>
<td>16.</td>
<td>Transportmetrica B-Transport Dynamics</td>
<td>2.520</td>
<td>10</td>
<td>97</td>
</tr>
<tr>
<td>17.</td>
<td>Journal of Air Transport Management</td>
<td>2.357</td>
<td>138</td>
<td>2383</td>
</tr>
<tr>
<td>18.</td>
<td>Transportation Research Part D-Transport and Environment</td>
<td>2.341</td>
<td>175</td>
<td>3572</td>
</tr>
<tr>
<td>19.</td>
<td>Transport Policy</td>
<td>2.269</td>
<td>147</td>
<td>3737</td>
</tr>
<tr>
<td>20.</td>
<td>International Journal of Engine Research</td>
<td>2.237</td>
<td>76</td>
<td>1232</td>
</tr>
<tr>
<td>21.</td>
<td>Mobilities</td>
<td>2.043</td>
<td>46</td>
<td>868</td>
</tr>
<tr>
<td>22.</td>
<td>Transportmetrica A-Transport Science</td>
<td>2.033</td>
<td>48</td>
<td>302</td>
</tr>
<tr>
<td>23.</td>
<td>International Journal of Sustainable Transportation</td>
<td>1.973</td>
<td>87</td>
<td>504</td>
</tr>
<tr>
<td>24.</td>
<td>Journal of Safety Research</td>
<td>1.841</td>
<td>51</td>
<td>2604</td>
</tr>
<tr>
<td>25.</td>
<td>Transportation Research Part F-Traffic Psychology and Behaviour</td>
<td>1.830</td>
<td>173</td>
<td>2637</td>
</tr>
<tr>
<td>26.</td>
<td>Journal of Advanced Transportation</td>
<td>1.813</td>
<td>86</td>
<td>796</td>
</tr>
<tr>
<td>27.</td>
<td>Journal of Intelligent Transportation Systems</td>
<td>1.769</td>
<td>43</td>
<td>543</td>
</tr>
<tr>
<td>28.</td>
<td>Maritime Policy &amp; Management</td>
<td>1.741</td>
<td>64</td>
<td>1171</td>
</tr>
<tr>
<td>29.</td>
<td>Journal of Transport &amp; Health</td>
<td>1.718</td>
<td>54</td>
<td>251</td>
</tr>
<tr>
<td>30.</td>
<td>Journal of Transport and Land Use</td>
<td>1.679</td>
<td>25</td>
<td>282</td>
</tr>
<tr>
<td>31.</td>
<td>Proceedings of The Institution of Mechanical Engineers Part F-Journal of Rail and Rapid Transit</td>
<td>1.537</td>
<td>148</td>
<td>1343</td>
</tr>
<tr>
<td>32.</td>
<td>Traffic Injury Prevention</td>
<td>1.677</td>
<td>156</td>
<td>1290</td>
</tr>
<tr>
<td>33.</td>
<td>Proceedings of The Institution of Mechanical Engineers Part F-Journal of Automobile Engineering</td>
<td>1.253</td>
<td>143</td>
<td>2309</td>
</tr>
<tr>
<td>34.</td>
<td>IET Intelligent Transport Systems</td>
<td>1.194</td>
<td>79</td>
<td>642</td>
</tr>
<tr>
<td>35.</td>
<td>Transport</td>
<td>1.163</td>
<td>45</td>
<td>424</td>
</tr>
<tr>
<td>36.</td>
<td>European Transport Research Review</td>
<td>0.962</td>
<td>26</td>
<td>195</td>
</tr>
<tr>
<td>37.</td>
<td>Journal of Transportation Engineering</td>
<td>0.962</td>
<td>98</td>
<td>3220</td>
</tr>
<tr>
<td>38.</td>
<td>Maritime Economics &amp; Logistics</td>
<td>0.939</td>
<td>26</td>
<td>519</td>
</tr>
<tr>
<td>39.</td>
<td>Journal of Transport Economics and Policy</td>
<td>0.935</td>
<td>17</td>
<td>1035</td>
</tr>
<tr>
<td>40.</td>
<td>International Journal of Automotive Technology</td>
<td>0.897</td>
<td>108</td>
<td>968</td>
</tr>
<tr>
<td>41.</td>
<td>Transportation Journal</td>
<td>0.897</td>
<td>15</td>
<td>464</td>
</tr>
<tr>
<td>42.</td>
<td>Research in Transportation Economics</td>
<td>0.781</td>
<td>73</td>
<td>669</td>
</tr>
<tr>
<td>43.</td>
<td>International Journal of Vehicle Design</td>
<td>0.713</td>
<td>54</td>
<td>709</td>
</tr>
<tr>
<td>44.</td>
<td>Journal of Public Transportation</td>
<td>0.710</td>
<td>27</td>
<td>544</td>
</tr>
<tr>
<td>45.</td>
<td>Transportation Letters-The International Journal of Transportation Research</td>
<td>0.706</td>
<td>27</td>
<td>186</td>
</tr>
<tr>
<td>46.</td>
<td>European Journal of Transport and Infrastructure Research</td>
<td>0.619</td>
<td>37</td>
<td>361</td>
</tr>
<tr>
<td>47.</td>
<td>International Journal of Shipping and Transport Logistics</td>
<td>0.609</td>
<td>23</td>
<td>173</td>
</tr>
<tr>
<td>48.</td>
<td>Transportation Research Record</td>
<td>0.598</td>
<td>848</td>
<td>16327</td>
</tr>
<tr>
<td>49.</td>
<td>Transportation Planning and Technology</td>
<td>0.474</td>
<td>50</td>
<td>550</td>
</tr>
<tr>
<td>50.</td>
<td>Journal of Transportation Safety &amp; Security</td>
<td>0.465</td>
<td>31</td>
<td>93</td>
</tr>
<tr>
<td>51.</td>
<td>Promet-Traffic &amp; Transportation</td>
<td>0.430</td>
<td>63</td>
<td>201</td>
</tr>
<tr>
<td>52.</td>
<td>Proceedings of the Institution of Civil Engineers-Transport</td>
<td>0.402</td>
<td>36</td>
<td>235</td>
</tr>
<tr>
<td>53.</td>
<td>International Journal of Heavy Vehicle Systems</td>
<td>0.308</td>
<td>20</td>
<td>102</td>
</tr>
<tr>
<td>54.</td>
<td>ITE Journal-Institute of Transportation Engineers</td>
<td>0.291</td>
<td>46</td>
<td>269</td>
</tr>
<tr>
<td>55.</td>
<td>International Journal of Transport Economics</td>
<td>0.220</td>
<td>16</td>
<td>189</td>
</tr>
<tr>
<td>56.</td>
<td>Road &amp; Transport Research</td>
<td>0.024</td>
<td>6</td>
<td>115</td>
</tr>
<tr>
<td></td>
<td>Summary</td>
<td>-</td>
<td>6190</td>
<td>89669</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhaocheng Du</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhaocheng Du</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
