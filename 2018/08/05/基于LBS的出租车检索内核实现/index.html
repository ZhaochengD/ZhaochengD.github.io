<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Data Structure,C++/C," />










<meta name="description" content="基于LBS的打车APP开发功能描述：现在我们想要开发一个类似于滴滴打车的软件，主要想要实现下面的两个功能： 在给定的一张北京地图上，有诸多的出租车车辆 功能1: range_query，在一个范围内，例如我们的屏幕范围内，显示出所有的出租车信息 功能2: knn_query，用户指定起点，可以获得距离最近的k辆车">
<meta name="keywords" content="Data Structure,C++&#x2F;C">
<meta property="og:type" content="article">
<meta property="og:title" content="基于LBS的出租车检索内核实现">
<meta property="og:url" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/index.html">
<meta property="og:site_name" content="Blogs of Zhaocheng">
<meta property="og:description" content="基于LBS的打车APP开发功能描述：现在我们想要开发一个类似于滴滴打车的软件，主要想要实现下面的两个功能： 在给定的一张北京地图上，有诸多的出租车车辆 功能1: range_query，在一个范围内，例如我们的屏幕范围内，显示出所有的出租车信息 功能2: knn_query，用户指定起点，可以获得距离最近的k辆车">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-07-25%2019-44-37屏幕截图.png">
<meta property="og:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-07-25%2019-47-28屏幕截图.png">
<meta property="og:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-07-26%2007-43-43屏幕截图.png">
<meta property="og:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-07-30%2000-17-25屏幕截图.png">
<meta property="og:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04%2023-06-02屏幕截图.png">
<meta property="og:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04%2011-12-37屏幕截图.png">
<meta property="og:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04%2011-15-06屏幕截图.png">
<meta property="og:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04%2021-29-14屏幕截图.png">
<meta property="og:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04%2021-29-29屏幕截图.png">
<meta property="og:updated_time" content="2018-08-20T08:37:44.630Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基于LBS的出租车检索内核实现">
<meta name="twitter:description" content="基于LBS的打车APP开发功能描述：现在我们想要开发一个类似于滴滴打车的软件，主要想要实现下面的两个功能： 在给定的一张北京地图上，有诸多的出租车车辆 功能1: range_query，在一个范围内，例如我们的屏幕范围内，显示出所有的出租车信息 功能2: knn_query，用户指定起点，可以获得距离最近的k辆车">
<meta name="twitter:image" content="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/2018-07-25%2019-44-37屏幕截图.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/"/>





  <title>基于LBS的出租车检索内核实现 | Blogs of Zhaocheng</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blogs of Zhaocheng</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/05/基于LBS的出租车检索内核实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaocheng Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs of Zhaocheng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基于LBS的出租车检索内核实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-05T23:14:35+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基于LBS的打车APP开发"><a href="#基于LBS的打车APP开发" class="headerlink" title="基于LBS的打车APP开发"></a>基于LBS的打车APP开发</h1><p><strong>功能描述</strong>：现在我们想要开发一个类似于滴滴打车的软件，主要想要实现下面的两个功能：</p>
<p>在给定的一张北京地图上，有诸多的出租车车辆</p>
<p>功能1: range_query，在一个范围内，例如我们的屏幕范围内，显示出所有的出租车信息</p>
<p>功能2: knn_query，用户指定起点，可以获得距离最近的k辆车</p>
<a id="more"></a>
<p><strong>面临问题与解决方案</strong></p>
<p>对于range_query</p>
<ul>
<li>如何存储北京的地图信息，使得信息检索最快，使用(<strong>使用网格索引</strong>与<strong>二维地图一维化</strong>存储，见第4部分)？</li>
<li>如何快速查找某一单位地域范围内的所有车辆信息(使用<strong>双向列表</strong>数据结构，见第2部分)？</li>
<li>如何快速查找某一车辆在哪一单位地域(使用<strong>哈希表</strong>数据结构，见第3部分)？</li>
</ul>
<p>对于knn_query</p>
<ul>
<li>如何快速查找距离最近(欧氏距离)的车辆(使用<strong>小顶堆</strong>数据结构，见第7部分)？</li>
<li>如何实现在堆中查找距离时的剪枝，从而提高查找效率(使用<strong>Bitmap</strong>数据结构，见第6部分)？</li>
</ul>
<p>下面就是正文了，正文的描述由下面的结构组成：</p>
<ol>
<li>介绍本次项目用到的<strong>C语言的基本知识</strong>以及<strong>相关概念</strong></li>
<li>介绍实现range_query的相关<strong>数据结构的理论</strong>及<strong>代码设计与编写</strong></li>
<li>实现range_query</li>
<li>介绍实现knn_query的相关<strong>数据结构的理论</strong>及<strong>代码设计与编写</strong></li>
<li>实现knn_query</li>
</ol>
<h2 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1.基本知识"></a>1.基本知识</h2><h3 id="1-1-索引相关知识"><a href="#1-1-索引相关知识" class="headerlink" title="1.1 索引相关知识"></a>1.1 索引相关知识</h3><p><strong>索引</strong>：索引是在一个数据集当中，索引无需对整个数据集进行扫描，就可以在其中找到所需要的数据的的一种就结构．注意以下两点：</p>
<ul>
<li>索引不是一个特定的结构，任何可以实现上述功能均可成为索引．</li>
<li>索引不是在物理上而是从逻辑上对数据进行排序．</li>
<li>索引的本质是拿空间换时间</li>
</ul>
<p><strong>空间索引</strong>: 对于一些空间数据，数据是多维度的(例如一些线段是二维的)，不能够通过简单的数据排序来进行建立索引，因此需要其他的算法来建立空间索引，主要有以下两种：</p>
<ul>
<li>基于最小包容块的算法(R-tree)</li>
<li>基于空间细分的方法(网格划分的索引)</li>
</ul>
<p>这里我们使用的是网格划分的索引。</p>
<h3 id="1-2-C中的位操作"><a href="#1-2-C中的位操作" class="headerlink" title="1.2 C中的位操作"></a>1.2 C中的位操作</h3><p>当我们声明一个为0的char1变量(有8 bit)时，我们得到了下面的这个数据</p>
<p>​                                                                 <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code>  </p>
<p>当我们声明一个为3的char2变量(有8 bit)时，我们得到了下面的这个数据</p>
<p>​                                                                 <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code> <code>1</code></p>
<ul>
<li><p><strong>位的与操作(&amp;)</strong></p>
<p>对每一个bit位分别进行与操作，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char1 &amp; char2</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code></p>
</li>
<li><p><strong>位的或操作(|)</strong></p>
<p>对每一个bit位分别进行或操作，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char1 | char2</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code> <code>1</code></p>
</li>
<li><p><strong>位的左移操作(&lt;&lt;)</strong></p>
<p>将所有bit位向左移一位，例如将char2的每一位左移2位，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char2 &lt;&lt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>最终的结果如下，转化为十进制为12</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code> <code>1</code> <code>0</code> <code>0</code></p>
</li>
<li><p><strong>位的右移操作(&lt;&lt;)</strong></p>
<p>将所有bit位向右移一位，例如将char2的每一位右移1位，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char2 &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>最终的结果如下，转化为十进制为</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code></p>
</li>
<li><p><strong>位的取反操作(~)</strong></p>
<p>将所有bit位每一位进行取反</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~char2</span><br></pre></td></tr></table></figure>
<p>最终的结果如下，转化为十进制为1</p>
<p>​                                                          <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>0</code> <code>0</code></p>
</li>
<li><p><strong>位的异或运算(^)</strong></p>
<p>若参加运算的两个二进制位值相同则为0，否则为1，语法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char1 ^ char2</span><br></pre></td></tr></table></figure>
<p>运算结果为：</p>
<p>​                                                          <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>1</code> <code>1</code></p>
</li>
</ul>
<h3 id="1-3-数据存储相关知识"><a href="#1-3-数据存储相关知识" class="headerlink" title="1.3 数据存储相关知识"></a>1.3 数据存储相关知识</h3><p>在本次编程这种涉及到了大量的<strong>分配内存</strong> 的操作，和之前变量声明有很大的不同，故记录。</p>
<ul>
<li><p><strong>栈区(stack)</strong>－－由编译器自动分配和释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。声明方式就是在C基础里学到的最基础的声明方式，会在函数结束的时候释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lbs_hashtable_t</span> hashtable;<span class="comment">//声明一个hashtable类型的变量hashtable</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>堆区(heap)</strong>－－一般由程序员分配和释放，若程序员不释放，程序结束时可能由OS回收，注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。在函数结束时仍然不会消失。常用的函数有<code>malloc</code>，<code>calloc</code>，<code>realloc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lbs_hashtable_t</span>* hashtable = (<span class="keyword">lbs_hashtable_t</span>*)<span class="built_in">malloc</span>(<span class="number">12</span> * <span class="keyword">sizeof</span>(<span class="keyword">lbs_hashtable_t</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全局区(静态区)(static)</strong>——全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放，声明使用<code>statistic</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">lbs_hashtable_t</span>* hashtable</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-4-宏的相关定义"><a href="#1-4-宏的相关定义" class="headerlink" title="1.4 宏的相关定义"></a>1.4 宏的相关定义</h3><p>宏简单的说就是字符串的替代操作，使用<code>#define</code>关键字来书写。</p>
<p>这里主要说明两种宏</p>
<ol>
<li>替代数值的宏</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LAT 103</span></span><br></pre></td></tr></table></figure>
<p>在后面的所有代码当中出现了<code>MIN_LAT</code>就被替换成了103</p>
<ol>
<li>作为函数的宏</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> #<span class="meta-keyword">define</span> lbs_queue_init(q) \</span></span><br><span class="line">  (q)-&gt;prev = (q);\</span><br><span class="line">  (q)-&gt;next = (q);</span><br></pre></td></tr></table></figure>
<p>作为函数的宏和普通的函数有些许的不同，不同在于:</p>
<p>(1) 宏不需要声明形参变量的类型</p>
<p>(2) 宏是以一句话终结作为一个宏识别的结束，而不是以分号</p>
<h2 id="2-双向列表数据结构"><a href="#2-双向列表数据结构" class="headerlink" title="2.双向列表数据结构"></a>2.双向列表数据结构</h2><p><strong>双向列表</strong>是在本次实现<strong>网格索引</strong>和<strong>哈希表</strong>的关键以及基础，因此先进行介绍双向列表．</p>
<h3 id="2-1-双向链表结构设计"><a href="#2-1-双向链表结构设计" class="headerlink" title="2.1 双向链表结构设计"></a>2.1 双向链表结构设计</h3><p><strong>双向列表</strong>的样子如下图所示，一个双向列表由多个<strong>双向列表的节点</strong>组成，在每一个节点当中我们分别使用两个指针指向前面和后面的节点，当我们遍历时，只需要取出该节点当中存储的下一个节点的地址，就可以快速访问下一个节点。</p>
<p><strong>注意</strong>：头结点(x1, y1)一般设置为空节点，这样方便新的节点的插入操作。</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-07-25 19-44-37屏幕截图.png" alt="2018-07-25 19-44-37屏幕截图"></p>
<p>首先熟悉一下双向列表的组成，双向列表的每一个节点由两部分组成：数据和指针．</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-07-25 19-47-28屏幕截图.png" alt="2018-07-25 19-47-28屏幕截图"></p>
<p>其中：</p>
<p>data属于数据域，是记录车辆的数据的区域；</p>
<p>prev属于指针域，是指向前一个node的指针；</p>
<p>next属于指针域，是指向后一个node的指针；</p>
<p>这里我们将数据域和指针域分别定义在<strong>不同的头文件</strong>里，以方便后期数据域的修改(在后期的<strong>哈希表数据结构</strong>和<strong>网格索引</strong>当中都使用到了指针域，但数据域有所不同)，下面是指针域部分，在lbs_queue.h头文件中书写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_queue.h</span></span><br><span class="line"><span class="comment">//定义指向前和后的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_queue_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lbs_queue_s</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lbs_queue_s</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">lbs_queue_t</span></span><br><span class="line"><span class="comment">//下接操作，接口１</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-车辆点结构设计"><a href="#2-2-车辆点结构设计" class="headerlink" title="2.2 车辆点结构设计"></a>2.2 车辆点结构设计</h3><p>这可以理解为一个车辆节点的数据结构，也可以理解为前面双向列表的数据域部分。<strong>第一行引入了双向列表</strong><code>queue。</code>主要涉及经纬度信息，车辆id信息，时间戳信息等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_defs.h</span></span><br><span class="line"><span class="comment">//定义数据域，并加入指针域，形成完整节点node</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lbs_queue.h"</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_mov_node_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">lbs_queue_t</span> <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">double</span> lon;</span><br><span class="line">    <span class="keyword">double</span> lat;</span><br><span class="line">    <span class="keyword">uint32_t</span> id;</span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp;</span><br><span class="line">&#125;<span class="keyword">lbs_mov_node_t</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-链表的相关操作"><a href="#2-3-链表的相关操作" class="headerlink" title="2.3 链表的相关操作"></a>2.3 链表的相关操作</h3><p>在定义了数据域和链表域以后就是定义链表指针的操作了，链表的操作主要是<strong>针对节点的操作</strong>，包括节点的<strong>初始化</strong>(建立一个空节点)，<strong>插入</strong>，<strong>删除</strong>和<strong>判空</strong>等，由于大一学习过，不做详细的解说．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_queue.h</span></span><br><span class="line"><span class="comment">//接口１</span></span><br><span class="line"><span class="comment">//初始化一个空的queue有节点,q是宏的参数，与函数不同，可以不做数据类型的声明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lbs_queue_init(q) \</span></span><br><span class="line">  (q)-&gt;prev = (q);\</span><br><span class="line">  (q)-&gt;next = (q);</span><br><span class="line"><span class="comment">//删除q节点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lbs_queue_remove(q) \</span></span><br><span class="line">  (q)-&gt;prev-&gt;next = (q)-&gt;next;\</span><br><span class="line">  (q)-&gt;next-&gt;prev = (q)-&gt;prev;</span><br><span class="line"><span class="comment">//把q插在h后面</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lbs_queue_insert_head(h,q)\</span></span><br><span class="line">  (q)-&gt;prev-&gt;next = (h);\</span><br><span class="line">  (h)-&gt;next       = (q);\</span><br><span class="line">  (q)-&gt;next       = (h)-&gt;next; \</span><br><span class="line">  (h)-&gt;next       = (q)</span><br><span class="line"><span class="comment">//判断链表是否为空(h节点下一个若是自己则为空)</span></span><br><span class="line">#define lbs_queue_empty(h)\</span><br><span class="line">  (h)-&gt;next == (h)</span><br></pre></td></tr></table></figure>
<h2 id="3-哈希表数据结构"><a href="#3-哈希表数据结构" class="headerlink" title="3.哈希表数据结构"></a>3.哈希表数据结构</h2><p>为什么要引入哈希表呢?答案是为了实现车辆快速的查找，说白了也是为了构建一种类似于索引的结构．具体会在后面讲述，暂时只是整理．</p>
<h3 id="3-1-算法原理"><a href="#3-1-算法原理" class="headerlink" title="3.1 算法原理"></a>3.1 算法原理</h3><p>哈希表的原理如下：对于一串关键字(我们称之为数字1)，通过<strong>哈希函数</strong>的计算，得到另一个数字(数字２)，此时这串得到的数字2就是该关键字对应的数据存储的物理地址．所以下一次我们得到了关键字数字1，想要查看该关键字对应的相关信息，只需要进行<strong>一次哈希计算</strong>，我们就知道它存储在了什么<strong>物理地址(数字2)</strong>上．然后我们在该物理地址上寻找就能找到这类信息．<strong>避免</strong>了进行一次次<strong>迭代</strong>的过程．</p>
<p>举例说明，我们获得了id = k，哈希函数是h(key)，则它存储的物理地址就是h(k)．常用的哈希函数方法如下：</p>
<ul>
<li>直接定址法</li>
<li>数字分析法</li>
<li>除留取余法</li>
</ul>
<p>下面我们选择最简单的方法<strong>除留取余法</strong>做个示范，这也是我们在后面真正的试验中会使用的方法．<strong>除留取余法</strong>就是哈希函数定义为h(key) = key%q，注意q有以下选择规则:</p>
<ul>
<li>q不应大于哈希表的长度</li>
<li>q应该尽量是一个质数</li>
</ul>
<p>简单起见，我们要定义哈希表的长度m = 8，q = 7．我们有一组关键字为{5,6,7,22,81,19,34 }，我们进行一下的计算过程，我们首先计算前五个数值:</p>
<p>5 % 7 = 5,  6 % 7 = 6,  7 % 7 = 0,  22%7 = 1,  81%7 = 4</p>
<table>
<thead>
<tr>
<th>h(key)</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td>7</td>
<td>22</td>
<td></td>
<td></td>
<td>81</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>这里的h(key)就是计算后存储的物理地址，key就是我们的关键字．然而在计算19和34时，却出现下面的问题：</p>
<p>19 % 7 = 5,   34%7 = 6  </p>
<p>物理位置5和6已经被5和6这两个关键字填充了，我们称之为发生了<strong>冲突</strong>．我们的解决方案就是利用上面的<strong>双向列表数据结构</strong>,得到以下的结构：</p>
<table>
<thead>
<tr>
<th>h(key)</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td>7</td>
<td>22</td>
<td></td>
<td></td>
<td>81</td>
<td>5</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>19</td>
<td>34</td>
</tr>
</tbody>
</table>
<p>转化一下形式就成了下图的样子:</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-07-26 07-43-43屏幕截图.png" alt="2018-07-26 07-43-43屏幕截图"></p>
<h3 id="3-2-哈希表节点结构设计"><a href="#3-2-哈希表节点结构设计" class="headerlink" title="3.2 哈希表节点结构设计"></a>3.2 哈希表节点结构设计</h3><p>首先我们看到在每一个<strong>链表节点</strong>的最前面有一个都有一个<strong>哈希表节点</strong>，下面我们首先实现哈希表节点，哈希节点主要需要存储</p>
<ul>
<li>一个可以进行链接<strong>前节点</strong>和<strong>后节点</strong>的双向列表queue结构</li>
<li>一个可以指向存储车辆数据mov_node地址的指针</li>
<li>一个cell 的 id</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_hashtable.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_hashnode_s</span>&#123;</span></span><br><span class="line">  <span class="comment">//我们需要一个链表来连接前面的和后面的节点</span></span><br><span class="line">  <span class="keyword">lbs_queue_t</span> <span class="built_in">queue</span>;</span><br><span class="line">  <span class="comment">//我们需要一个指向mov_node的指针(并不真正用它存储数据)</span></span><br><span class="line">  <span class="keyword">lbs_mov_node_t</span>* mov_node;</span><br><span class="line">  <span class="comment">//一个cell的id</span></span><br><span class="line">  <span class="keyword">int</span> cell_id;</span><br><span class="line">&#125;<span class="keyword">lbs_hashnode_t</span></span><br><span class="line"><span class="comment">//接口2</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-哈希表结构设计"><a href="#3-3-哈希表结构设计" class="headerlink" title="3.3 哈希表结构设计"></a>3.3 哈希表结构设计</h3><p>随后我们需要编写hashtable的结构(hashtable由多个hashnode组成)，这里需要一下数据:</p>
<ul>
<li>hashnode的数量Capacity</li>
<li>node已经被占用的数量size</li>
<li>指向下一个hashnode的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_hashtable_s</span>&#123;</span></span><br><span class="line">  <span class="comment">//哈希表节点的个数(多少个hashnode)</span></span><br><span class="line">  <span class="keyword">int</span> capacity;</span><br><span class="line">  <span class="comment">//哈希节点被占用的个数</span></span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">//一个声明存储hashnode的头地址</span></span><br><span class="line">  <span class="keyword">lbs_hashnode_t</span>* hash_nodes;</span><br><span class="line">&#125;<span class="keyword">lbs_hashtable_t</span></span><br><span class="line"><span class="comment">//接口3</span></span><br></pre></td></tr></table></figure>
<p>继续定义哈希表的方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口3</span></span><br><span class="line"><span class="comment">//初始化一个hashtable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_init</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable)</span></span>;</span><br><span class="line"><span class="comment">//销毁一个hashtable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_destroy</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable)</span></span>;</span><br><span class="line"><span class="comment">//设置一个hashtable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_set</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable, <span class="keyword">uint32_t</span> id, <span class="keyword">lbs_mov_node_t</span>* lbs_mov_node, <span class="keyword">int</span> cell_id)</span></span>;</span><br><span class="line"><span class="comment">//提取一个hashtable的信息</span></span><br><span class="line"><span class="keyword">lbs_hashnode_t</span>* lbs_hashtable_get(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable, <span class="keyword">uint32_t</span> id);</span><br></pre></td></tr></table></figure>
<p>下面介绍每一个方法的实现方法(实现在cpp中文件编写即可):</p>
<h3 id="3-4-哈希表的初始化"><a href="#3-4-哈希表的初始化" class="headerlink" title="3.4 哈希表的初始化"></a>3.4 哈希表的初始化</h3><p>首先是结构体的<strong>初始化</strong>，结构体的初始化就是给init函数传入变量，使得函数中的每个值赋予结构体内的变量:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_hashtable.cpp</span></span><br><span class="line"><span class="comment">//初始化一个hashtable_node</span></span><br><span class="line"><span class="comment">//注意传入的是指针的hashtable类型，因此需要malloc分配动态内存，使用-&gt;访问成员</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_init</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable)</span></span>&#123;</span><br><span class="line">  lbs_hashtable-&gt;size = <span class="number">0</span>;</span><br><span class="line">  lbs_hashtable-&gt;capacity-&gt; = <span class="number">19997</span>;</span><br><span class="line">  <span class="comment">//((lbs_hashtable_t *)强制数据类型转化，malloc动态分配，sizeof()计算内存大小，)</span></span><br><span class="line">  lbs_hashtable-&gt;hashnode = (<span class="keyword">lbs_hashtable_t</span> *)<span class="built_in">malloc</span>\</span><br><span class="line">      (lbs_hashtable-&gt;capacity * <span class="keyword">sizeof</span>(lbs_hashnode_s))</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lbs_hashtable-&gt;Capacity; i++)&#123;</span><br><span class="line">    <span class="comment">//当传入的是struct变量，而不是指针，例如下文中的queue，使用.访问成员，不用分配内存</span></span><br><span class="line">    lbs_queue_init(&amp;(lbs_hashtable-&gt;hash_nodes[i].<span class="built_in">queue</span>))     </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-哈希表析构函数"><a href="#3-5-哈希表析构函数" class="headerlink" title="3.5 哈希表析构函数"></a>3.5 哈希表析构函数</h3><p>其次是结构体的析构函数，析构函数是对于有malloc分配内存的指针，使用free()析构掉．由于hashtable中的hashnode是一个连续的数组，因此只需要析构头地址。结构体的析构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上,lbs_hashtable.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_destroy</span><span class="params">(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable)</span></span>&#123;</span><br><span class="line">  lbs_hashtable-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">  lbs_hashtable-&gt;size = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">free</span>(lbs_hashtable-&gt;hashnode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6-设置一个哈希节点并插入哈希表"><a href="#3-6-设置一个哈希节点并插入哈希表" class="headerlink" title="3.6 设置一个哈希节点并插入哈希表"></a>3.6 设置一个哈希节点并插入哈希表</h3><p>设置一个节点，初始化一个hashnode，并且将存入数据的hashnode插入一个列表当中．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上,lbs_hashtable.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_hashtable_set</span><span class="params">(<span class="keyword">lbs_hashtable_t</span> * lbs_hashtable,</span></span></span><br><span class="line">                      unit32_t id, lbs_mov_node_t * lbs_mov_node, int cell_id):&#123;</span><br><span class="line">  hashnode-&gt;cell_id = cell_id;</span><br><span class="line">  hashnode-&gt;mov_node = lbs_move_node;</span><br><span class="line">  lbs_queue_init(hashnode-&gt;<span class="built_in">queue</span>);</span><br><span class="line">  <span class="keyword">int</span> index = id % (lbs_hashtable-&gt;capacity);</span><br><span class="line">  lbs_queue_insert_head(lbs_hashtable-&gt;hash_nodes[index].<span class="built_in">queue</span>,hashnode-&gt;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-获取哈希节点信息"><a href="#3-7-获取哈希节点信息" class="headerlink" title="3.7 获取哈希节点信息"></a>3.7 获取哈希节点信息</h3><p>根据一辆车的id提取一个hashtable的信息．其基本呢逻辑如下：</p>
<ul>
<li>通过id计算某一车辆信息存储的哈希表头位置</li>
<li>对哈希表内存储的双向链表进行一一迭代，找到该id车辆所对应的信息，如果没有的话，返回NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上,lbs_hashtable.cpp</span></span><br><span class="line"><span class="keyword">lbs_hashnode_t</span>* lbs_hashtable_get(<span class="keyword">lbs_hashtable_t</span>* lbs_hashtable, <span class="keyword">uint32_t</span> id)&#123;</span><br><span class="line">  <span class="comment">//初始化头结点和头结点的下一个节点</span></span><br><span class="line">  index = id % (lbs_hashtable-&gt;capacity);</span><br><span class="line">  <span class="keyword">lbs_hashnode_t</span>* headnode = lbs_hashtable-&gt;hashnode+index;</span><br><span class="line">  <span class="keyword">lbs_hashnode_t</span>* curnode = (<span class="keyword">lbs_hashnode_t</span>* )headnode-&gt;<span class="built_in">queue</span>.next;</span><br><span class="line">  <span class="comment">//不断迭代，直到找到相同的id为止</span></span><br><span class="line">  <span class="keyword">while</span>(headnode != curnode)&#123;</span><br><span class="line">    <span class="keyword">if</span> (curnode-&gt;mov_node-&gt;id == id)&#123;</span><br><span class="line">      <span class="keyword">return</span> curnode;      </span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      curnode = (<span class="keyword">lbs_hashnode_t</span>* )curnode-&gt;<span class="built_in">queue</span>.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lbs_hashtable.cpp结束</span></span><br></pre></td></tr></table></figure>
<h2 id="4-二维数组的网格降维处理"><a href="#4-二维数组的网格降维处理" class="headerlink" title="4. 二维数组的网格降维处理"></a>4. 二维数组的网格降维处理</h2><p>在我们获得一个二维的区域，首先我们需要将其网格化，网格化之后，我们就获得了每一个网格的编号等信息，按照编号进行存储，我们就<strong>从二位数组转化成了一维数组</strong>，实现了降维的操作．这样降维处理的主要原因是一维数组分配的是<strong>一组连续的数组</strong>，为对于二维数组则分配的空间则并不连续，影响数据处理的速度。</p>
<p>在定义网格结构体之前，我们首先想到如下的网格结构，有一下看点：</p>
<ul>
<li>一个地图被分为了许多的cell</li>
<li>每一个cell里存储这个cell里的车辆的信息</li>
<li>注意cell的编号从0—12，在物理存储中是连续的，因此转化为了一维的数组</li>
</ul>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-07-30 00-17-25屏幕截图.png" alt="2018-07-30 00-17-25屏幕截图"></p>
<h3 id="4-1-网格结构设计及其属性"><a href="#4-1-网格结构设计及其属性" class="headerlink" title="4.1 网格结构设计及其属性"></a>4.1 网格结构设计及其属性</h3><ul>
<li>每一个网格都有很多的cell</li>
<li>每一个cell里都要初始化一个<strong>空的双向列表</strong>(dammy node)来存储出租车信息。</li>
<li>每一个格子都应该有一个<strong>进程锁</strong>，来确保不会有多个用户同时访问</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_grid.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_cell_s</span> &#123;</span></span><br><span class="line">  <span class="comment">//dammy node</span></span><br><span class="line">  <span class="keyword">lbs_mov_node_t</span> dammy_node;</span><br><span class="line">  <span class="comment">//锁</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125; <span class="keyword">lbs_cell_t</span>;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<p>其次，我们定义网格数据结构的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_grid_s</span> &#123;</span></span><br><span class="line">  <span class="comment">//row num of grid</span></span><br><span class="line">  <span class="keyword">int</span> row_num;</span><br><span class="line">  <span class="comment">//col num of grid</span></span><br><span class="line">  <span class="keyword">int</span> col_num;</span><br><span class="line">  <span class="comment">//cell width</span></span><br><span class="line">  <span class="keyword">double</span> cell_width;</span><br><span class="line">  <span class="comment">//cell height</span></span><br><span class="line">  <span class="keyword">double</span> cell_height;</span><br><span class="line">  <span class="comment">//grid lon minimum value</span></span><br><span class="line">  <span class="keyword">double</span> lon_min;</span><br><span class="line">  <span class="comment">//grid lat minimum value</span></span><br><span class="line">  <span class="keyword">double</span> lat_min;</span><br><span class="line">  <span class="comment">//哈希表</span></span><br><span class="line">  <span class="keyword">lbs_hashtable_t</span> hash_table;</span><br><span class="line">  <span class="comment">//所有的cells</span></span><br><span class="line">  <span class="keyword">lbs_cell_t</span>* cell;</span><br><span class="line">&#125; <span class="keyword">lbs_grid_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网络的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_init</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon1, <span class="keyword">double</span> lon2, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lat2, <span class="keyword">int</span> row_num, <span class="keyword">int</span> col_num)</span></span>;</span><br><span class="line"><span class="comment">//网格的删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_destroy</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid)</span></span>;</span><br><span class="line"><span class="comment">//更新移动位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_update</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">uint64_t</span> timestamp, <span class="keyword">uint32_t</span> id)</span></span>;</span><br><span class="line"><span class="comment">//计算cell row</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_row</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lat)</span></span>;</span><br><span class="line"><span class="comment">//计算cell col</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_col</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon)</span></span>;</span><br><span class="line"><span class="comment">//计算cell id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_id</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_row, <span class="keyword">int</span> cell_col)</span></span>;</span><br><span class="line"><span class="comment">//给出id，返回row和col</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lbs_grid_cell_row_col</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_id, <span class="keyword">int</span>* cell_row, <span class="keyword">int</span>* cell_col)</span></span>;</span><br><span class="line"><span class="comment">//获取cell_id里面的cell</span></span><br><span class="line"><span class="keyword">lbs_cell_t</span>* lbs_grid_cell(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_id);</span><br><span class="line"><span class="comment">//结束lbs_grid.h</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2网格数据结构初始化"><a href="#4-2网格数据结构初始化" class="headerlink" title="4.2网格数据结构初始化"></a>4.2网格数据结构初始化</h3><p>在<code>.cpp</code>文件中分别对每一个函数进行编写，首先是对网格的初始化，这里注意：</p>
<ul>
<li>由于cell是一个一维的数组，因此在初始化时需要使用<code>malloc</code>分配连续的空间。</li>
<li>在分配给每个cell存储空间以后，还需要对cell里面的链表进行初始化：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_grid.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_init</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon1, <span class="keyword">double</span> lon2, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lat2, <span class="keyword">int</span> row_num, <span class="keyword">int</span> col_num)</span></span>&#123;</span><br><span class="line"> lbs_grid-&gt;row_num = row_num;</span><br><span class="line"> lbs_grid-&gt;col_num = col_num;</span><br><span class="line"> lbs_grid-&gt;lon_min = lon1;</span><br><span class="line"> lbs_grid-&gt;lat_min = lat1;</span><br><span class="line"> lbs_grid-&gt;cell_width = (lon2-lon1)/col_num;</span><br><span class="line"> lbs_grid-&gt;cell_height = (lat2-lat1)/row_num; </span><br><span class="line"> lbs_hashtable_init(&amp;lbs_grid-&gt;hashtable);</span><br><span class="line"> lbs_grid-&gt;cell = (<span class="keyword">lbs_cell_t</span>* )<span class="built_in">malloc</span>(row_num*col_num*<span class="keyword">sizeof</span>(<span class="keyword">lbs_cell_t</span>));</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row_num*col_num; i++)&#123;</span><br><span class="line">   lbs_queue_init(&amp;(lbs_grid-&gt;cell[i].dammy_node.<span class="built_in">queue</span>));     </span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-网络数据结构析构"><a href="#4-3-网络数据结构析构" class="headerlink" title="4.3 网络数据结构析构"></a>4.3 网络数据结构析构</h3><p>网格的析构，由于每一个内部都被赋予了初值——<code>dammy_node</code>，所以在释放内存的时候需要对每一个<code>cell</code>的地址进行释放内存。:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_destroy</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid)</span></span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(lbs_grid-&gt;cell)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row_num*col_num; i == <span class="number">0</span>; i--)&#123;</span><br><span class="line">      <span class="built_in">free</span>(cell + i);    </span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-在屏幕发生变化时更新节点信息"><a href="#4-4-在屏幕发生变化时更新节点信息" class="headerlink" title="4.4 在屏幕发生变化时更新节点信息"></a>4.4 在屏幕发生变化时更新节点信息</h3><p>网格数据内车辆信息的更新，分为以下几个步骤完成：</p>
<ul>
<li>1.根据传入的车辆lon, lat 号计算该点所在的new_cell_id</li>
<li>2.根据传入的id 号计算该节点所在的hashnode，并从hashtable中获取该车辆原本的old_cell_id</li>
<li>3.判断该hashnode是否为空，为空则说明这辆车是新到的，所以加入hash表当中；如果不为空，则说明这辆车原本就存在，进而转入下一次判断</li>
<li>4.判断new_cell_id是否等于old_cell_id，如果等于的话，不做改变；否则删除原hashnode节点，插入新hashnode节点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_update</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">uint64_t</span> timestamp, <span class="keyword">uint32_t</span> id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">lbs_hashnode_t</span>* hashnode = lbs_hashtable_get(&amp;(lbs_grid-&gt;hashtable), id);</span><br><span class="line">  <span class="keyword">int</span> cell_row_new = lbs_grid_cell_row(&amp;(lbs_grid), lat);</span><br><span class="line">  <span class="keyword">int</span> cell_col_new = lbs_grid_cell_col(&amp;(lbs_grid), lon);</span><br><span class="line">  <span class="keyword">int</span> cell_id_new = lbs_grid_col(cell_row, cell_col);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在没有该节点的情况下</span></span><br><span class="line">  <span class="keyword">if</span> (hashnode == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//更新mov_node</span></span><br><span class="line">    <span class="keyword">lbs_mov_node_t</span>* new_lbs_mov_node = (<span class="keyword">lbs_mov_node_t</span>* )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">lbs_mov_node_t</span>));</span><br><span class="line">    <span class="comment">//new_lbs_queue_init(lbs_mov_node-&gt;queue);</span></span><br><span class="line">    new_lbs_mov_node-&gt;lon = lon;</span><br><span class="line">    new_lbs_mov_node-&gt;lat = lat;</span><br><span class="line">    new_lbs_mov_node-&gt;id = id;</span><br><span class="line">    new_lbs_mov_node-&gt;timestamp = timestamp;</span><br><span class="line">    <span class="comment">//重设hashnode</span></span><br><span class="line">    <span class="keyword">int</span> temp = lbs_hashtable_set(&amp;(lbs_grid-&gt;lbs_hashtable), id, new_lbs_mov_node, cell_id_new);</span><br><span class="line">    lbs_queue_insert_head(&amp;(lbs_grid-&gt;cell[cell_id_new].dammy_node.<span class="built_in">queue</span>), &amp;(new_lbs_mov_node.<span class="built_in">queue</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在需要更新的情况下</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cell_id_new != cell_id_old)&#123;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;lon = lon;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;lat = lat;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;timestamp = timestamp;</span><br><span class="line">      hashnode-&gt;cell_id = cell_id_new;</span><br><span class="line">      lbs_queue_remove(&amp;(hashnode-&gt;mov_node-&gt;<span class="built_in">queue</span>));</span><br><span class="line">      lbs_queue_insert_head(&amp;(lbs_grid-&gt;cell[cell_id_new].dammy_node.<span class="built_in">queue</span>), &amp;(hashnode-&gt;mov_node-&gt;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要更新的情况下</span></span><br><span class="line">    <span class="keyword">else</span> (cell_id_new == cell_id_old)&#123;</span><br><span class="line">      <span class="keyword">int</span> cell_id_old = hashnode -&gt; cell_id;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;lon = lon;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;lat = lat;</span><br><span class="line">      hashnode-&gt;mov_node-&gt;timestamp = timestamp;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-获取网格属性"><a href="#4-5-获取网格属性" class="headerlink" title="4.5 获取网格属性"></a>4.5 获取网格属性</h3><p>最后还有一些简单的函数，用来实现</p>
<ul>
<li>根据id获得行号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//计算cell row</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_row</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lat)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> row = (lat - (lbs_grid-&gt;lat_min)) / (lbs_grid-&gt;cell_height);</span><br><span class="line">  <span class="keyword">return</span> row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据id获得列号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//计算cell col</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_col</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> lon)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> col = (lon - (lbs_grid-&gt;lon_min)) / (lbs_grid-&gt;cell_width);</span><br><span class="line">  <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据col和row获得id</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//计算cell id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_cell_id</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_row, <span class="keyword">int</span> cell_col)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = (lbs_grid-&gt;col_num) * cell_row + cell_col;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据id同时获得行和列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//计算row 和 col</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lbs_grid_cell_row_col</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_id, <span class="keyword">int</span>* cell_row, <span class="keyword">int</span>* cell_col)</span> </span>&#123;</span><br><span class="line">  *cell_row = cell_id / lbs_grid-&gt;col_num;</span><br><span class="line">  *cell_col = cell_id % lbs_grid-&gt;col_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据id获取整个cell</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_grid.cpp</span></span><br><span class="line"><span class="comment">//获取cell id 里面的 cell</span></span><br><span class="line"><span class="keyword">lbs_cell_t</span>* lbs_grid_cell(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">int</span> cell_id)&#123;</span><br><span class="line">  <span class="keyword">if</span> (lbs_grid!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(lbs_grid-&gt;cell[cell_id]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lbs_grid.cpp结束</span></span><br></pre></td></tr></table></figure>
<h2 id="5-实现网格范围索引-range-query"><a href="#5-实现网格范围索引-range-query" class="headerlink" title="5. 实现网格范围索引(range_query)"></a>5. 实现网格范围索引(range_query)</h2><h3 id="5-1进行网格范围索引的最终结构"><a href="#5-1进行网格范围索引的最终结构" class="headerlink" title="5.1进行网格范围索引的最终结构"></a>5.1进行网格范围索引的最终结构</h3><p>终于到了可以实现range_query的时候了，上面讲解了许多的数据结构都是为了可以实现这个功能服务的，下面首先看一下在我们构建了所有的数据结构以后，获得的最终结构的图像：</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 23-06-02屏幕截图.png" alt="2018-08-04 23-06-02屏幕截图"></p>
<p>分别解说：</p>
<ol>
<li>在左侧红白相间的是<strong>哈希表</strong>结构，<strong>哈希表</strong>的是一串具有连续地址的数组，每一个地址当中存了一个空的哈希表节点(包含<strong>双向列表</strong>)。在它的后面使用<strong>哈希节点</strong>存储了车辆的信息，每一个节点是一个车辆，<strong>哈希节点</strong>之间使用<strong>双向列表</strong>链接。那么我们是怎么确定一个车辆的信息是挂载在哪个节点上的呢？就是对车辆ID进行求余，例如对第1辆车的ID求余以后得到了1，我们就把它挂载在第一个哈希节点上。</li>
<li>右下角的网格就是我们的地图，由于我们将二维的网格降维了，所以二维的网格也是通过一组地址连续的一维数组存储的。每一个网格里面存储了<strong>双向列表</strong>的一个头结点，后面挂载在了这个网格当中的车辆的节点。</li>
<li>我们想要查找一个网格里的车辆信息，只需要找到网格，对网格里的<strong>双向列表节点</strong>进行遍历即可。</li>
<li>我们想要查找一个车辆在哪个网格里，只需要对该车辆的id<strong>求余</strong>，找到对应的<strong>哈希表节点</strong>，再对后面的哈希节点遍历即可。</li>
</ol>
<p>下面就是我们代码部分了。</p>
<h3 id="5-2-存储节点结构设计"><a href="#5-2-存储节点结构设计" class="headerlink" title="5.2 存储节点结构设计"></a>5.2 存储节点结构设计</h3><p>存储节点用来存储查询到的车辆信息。其结构与之前定义的<code>lbs_mov_node</code>相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_index.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_res_node_s</span> &#123;</span></span><br><span class="line">  <span class="keyword">lbs_queue_t</span> <span class="built_in">queue</span>;   <span class="comment">// 返回结果的链表</span></span><br><span class="line">  <span class="keyword">double</span>   lon;        <span class="comment">// 纬度</span></span><br><span class="line">  <span class="keyword">double</span>   lat;        <span class="comment">// 经度</span></span><br><span class="line">  <span class="keyword">uint32_t</span> id;         <span class="comment">// 出租车唯一ID号</span></span><br><span class="line">  <span class="keyword">uint64_t</span> timestamp;  <span class="comment">// 时间戳</span></span><br><span class="line">&#125; <span class="keyword">lbs_res_node_t</span>;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-定义索引方法"><a href="#5-3-定义索引方法" class="headerlink" title="5.3 定义索引方法"></a>5.3 定义索引方法</h3><p>由于在range_query和knn_query都是在同一个<code>.cpp</code>文件当中声明的，所以最后一个<code>lbs_grid_index_nn_query()</code>函数在第8部分不再单独声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_index.h</span></span><br><span class="line"><span class="comment">// 初始化网格索引</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lbs_grid_index_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 更新接口[出租车位置更新]</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lbs_grid_index_update</span><span class="params">(<span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">uint64_t</span> timestamp, <span class="keyword">uint32_t</span> id)</span></span>;</span><br><span class="line"><span class="comment">// 范围查询接口[查询某一范围内的所有出租车信息]</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lbs_grid_index_range_query</span><span class="params">(<span class="keyword">double</span> lon1, <span class="keyword">double</span> lon2, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lat2, <span class="keyword">lbs_res_node_t</span>* out)</span></span>;</span><br><span class="line"><span class="comment">// KNN查询接口[查询离lon,lat最近的出租车]</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lbs_grid_index_nn_query</span><span class="params">(<span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">lbs_res_node_t</span>* out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lbs_index.h终止</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-初始化网格索引"><a href="#5-4-初始化网格索引" class="headerlink" title="5.4 初始化网格索引"></a>5.4 初始化网格索引</h3><p>方法同初始化网格，只是提供一个接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_index.cpp</span></span><br><span class="line"><span class="comment">// 初始化网格索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_index_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = lbs_grid_init(&amp;lbs_grid, LBS_LON_MIN, LBS_LON_MAX, LBS_LAT_MIN, LBS_LAT_MAX, LBS_ROW_NUM, LBS_COL_NUM);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="5-5-定义网格更新接口"><a href="#5-5-定义网格更新接口" class="headerlink" title="5.5 定义网格更新接口"></a>5.5 定义网格更新接口</h3><p>也在网格更新当中书写过了，直接调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_index.cpp</span></span><br><span class="line"><span class="comment">// 更新接口[出租车位置更新]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_index_update</span><span class="params">(<span class="keyword">double</span> lon,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">double</span> lat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">uint64_t</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">uint32_t</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = lbs_grid_update(&amp;lbs_grid, lon, lat, timestamp, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="5-6-实现range-query函数"><a href="#5-6-实现range-query函数" class="headerlink" title="5.6 实现range_query函数"></a>5.6 实现range_query函数</h3><p>重温一下range_query的功能，range_query是可以显示一个屏幕显示范围内的全部车辆信息，我们要解决两个问题：</p>
<ul>
<li>如何快？最快的方法当然是遍历，但效率很低，我们写这些数据结构就是为了让查找更快的。</li>
<li>对于一个只有半个格子在屏幕中的格子我们如何处理。</li>
</ul>
<p>对此，我们实现range_query的步骤如下：</p>
<p><strong>step1</strong> 我们得到屏幕四个角的经纬度，分别为<code>lat1</code>,<code>lat2</code>, <code>lon1</code>, <code>lon2</code>。</p>
<p><strong>step2</strong> 分别找出四个角对应的<code>cell_id</code>。</p>
<p><strong>step3</strong> 对每一个格子里的每一个车辆节点进行遍历，判断是否在格子内。</p>
<p><strong>step4</strong> 在格子内的话就存入我们之前定义的<code>lbs_res_node</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上lbs_index.cpp</span></span><br><span class="line"><span class="comment">// 范围查询接口[查询某一范围内的所有出租车信息]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_index_range_query</span><span class="params">(<span class="keyword">double</span> lon1,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">double</span> lon2,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">double</span> lat1,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">double</span> lat2,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">lbs_res_node_t</span>* out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = lbs_grid_cell_row(&amp;lbs_grid, lat1);</span><br><span class="line">  <span class="keyword">int</span> col1 = lbs_grid_cell_col(&amp;lbs_grid, lon1);</span><br><span class="line">  <span class="keyword">int</span> row2 = lbs_grid_cell_row(&amp;lbs_grid, lat2);</span><br><span class="line">  <span class="keyword">int</span> col2 = lbs_grid_cell_row(&amp;lbs_grid, lon2);</span><br><span class="line">  <span class="comment">//对每一个格子进行遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row1; i &lt; row2; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = col1; j &lt; col2; j ++)&#123;</span><br><span class="line">      <span class="keyword">int</span> cell_id = lbs_grid_cell_id(&amp;lbs_grid, i, j);</span><br><span class="line">      <span class="comment">//找到id对应的cell的地址</span></span><br><span class="line">      <span class="keyword">lbs_cell_t</span>* lbs_cell = lbs_grid_cell(&amp;lbs_grid, cell_id);</span><br><span class="line">      <span class="comment">//对该cell里的双向列表进行遍历</span></span><br><span class="line">      <span class="keyword">lbs_mov_node_t</span>* headnode = (lbs_mov_node* )&amp;(lbs_cell-&gt;dammy_node.<span class="built_in">queue</span>);</span><br><span class="line">      <span class="keyword">lbs_mov_node_t</span>* currnode = (lbs_mov_node* )&amp;(lbs_cell-&gt;dammy_node.<span class="built_in">queue</span>.next);</span><br><span class="line">      <span class="keyword">while</span>(currnode != headnode)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((currnode-&gt;lon &lt;= lon2) &amp;&amp; (currnode-&gt;lon &gt;= lon1) &amp;&amp; (currnode-&gt;lat &gt;= lat1) &amp;&amp; (currnode-&gt;lat &lt;= lat2))&#123;</span><br><span class="line">          <span class="keyword">lbs_res_node_t</span>* currnode_cloned = (lbs_mov_node* )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">lbs_mov_node_t</span>));</span><br><span class="line">          <span class="built_in">memcpy</span>(currnode_cloned, currnode, <span class="keyword">sizeof</span>(<span class="keyword">lbs_res_node_t</span>));</span><br><span class="line">          lbs_queue_insert_head(&amp;(out-&gt;<span class="built_in">queue</span>), &amp;(currnode_cloned-&gt;<span class="built_in">queue</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        currnode = (<span class="keyword">lbs_mov_node_t</span>* )currnode-&gt;<span class="built_in">queue</span>.next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见第8部分</span></span><br></pre></td></tr></table></figure>
<h2 id="6-Bitmap数据结构"><a href="#6-Bitmap数据结构" class="headerlink" title="6. Bitmap数据结构"></a>6. Bitmap数据结构</h2><p><strong>BItmap</strong>是一个常用的数据结构，常常用来表示在一个连续的编号体系当中，哪些编号对应的物理内存已经被占用，哪些没有，使用相当的高效。</p>
<h3 id="6-1-Bitmap算法原理"><a href="#6-1-Bitmap算法原理" class="headerlink" title="6.1 Bitmap算法原理"></a>6.1 Bitmap算法原理</h3><p>Bitmap是以位(Bit)作为基本的操作单位，一个位只有0和1两种状态。而我们指导计算机的基本存储单位是字节(Byte)，一个(Byte)中有8个位，因此我们想要对位进行基本操作，仅靠传统的加减乘除是不肯能的，只能通过<strong>位操作</strong>来进行。相关的位运算记录在了基础知识这一章中。</p>
<p><strong>提出问题:</strong>  我们现在有一组<strong>连续的</strong>内存地址用来存储网格cell的id，假设我们有id 1, 2, 3, 4, 5, 6, 7, 8, 9, 10，再假设我们需要按照<strong>一定的规则对每个cell进行一次遍历</strong>，可是<strong>该规则会多次涉及到已经遍历过的cell</strong>，问如何使用一种最快速，最节省内存的方法保存<strong>已经遍历过的id</strong>和<strong>未遍历的id</strong>?</p>
<p><strong>解决方案</strong>:</p>
<p>首先我们分配出来16个bit位均初始化为0。为什么不是10个？因为电脑的存储的最小单位是Byte，<code>1Byte = 8bits</code>，所以我们只能取到8的倍数。</p>
<p>​                                  <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code>    |     <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code></p>
<p>假设我们第一次迭代需要检查1, 2, 3, 在检查过这三个之后我们后面就再也不需要检查了，此时每一个位均为0，因此我们将前三位设置为1。</p>
<p>​                                  <code>1</code> <code>1</code> <code>1</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code>    |     <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code></p>
<p>假设我们第一次迭代需要检查3, 5, 6, 此时3我们已经检查过了，不需要再次检查，因此我们将5与6设置为1。在这里我们需要定义一个<strong>检查某一位是否为1的函数</strong>。</p>
<p>如此迭代往复，直到前10位都是1为止。</p>
<p>​                                  <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code>    |     <code>1</code> <code>1</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code></p>
<p>由此可见，Bitmap适用于非重复整形数组的一些问题，常用于<strong>数组的排序</strong>以及<strong>存储地址是否为空</strong>的判断等。</p>
<h3 id="6-2-Bitmap结构设计"><a href="#6-2-Bitmap结构设计" class="headerlink" title="6.2 Bitmap结构设计"></a>6.2 Bitmap结构设计</h3><p>这里我们熟悉一些简单的变量结构体(这些结构体是type类型的，但不是基本数据类型，由于公认和使用方便而被定义):</p>
<ul>
<li>uint8_t为结构体，原结构unsigned char</li>
<li>uint16_t为结构体，原结构unsigned short int</li>
<li>uint32_t为结构体，原结构unsighned int</li>
<li>uint64_t为结构体，原结构unsigned long int</li>
</ul>
<p>由于在C语言当中可以声明的最小变量是char类型(uint8_t)，所以这里我们使用char(uint8_t)类型来完成Bitmap数据结构的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_bitmap.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_bitmap_s</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> *bits;</span><br><span class="line">        <span class="keyword">uint32_t</span> bits_num;</span><br><span class="line">&#125; <span class="keyword">lbs_bitmap_t</span>;</span><br><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_init</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> bits_num)</span></span>;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_destroy</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap)</span></span>;</span><br><span class="line"><span class="comment">//设置pos位为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_setbit</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//设置pos位为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_unsetbit</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//判断pos位是否为1，为1返回1，为0返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_isset</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//结束lbs_bitmap.h</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3Bitmap的初始化"><a href="#6-3Bitmap的初始化" class="headerlink" title="6.3Bitmap的初始化"></a>6.3Bitmap的初始化</h3><ul>
<li>根据参数<code>bitnum</code>计算出我们需要声明多少个uint8_t变量</li>
<li>以<code>bits</code>作为首地址，分配这些uint8_t变量</li>
<li>均初始化为0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_init</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> bits_num)</span></span>&#123;</span><br><span class="line">  lbs_bitmap-&gt;bits_num = bits_num;</span><br><span class="line">  <span class="keyword">int</span> uint8_num = bits_num / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">  lbs_bitmap-&gt;bits = (<span class="keyword">uint8_t</span>* )<span class="built_in">calloc</span>(uint8_num, <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>) );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i == uint8_num; i++)&#123;</span><br><span class="line">    lbs_bitmap-&gt;bits[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-Bitmap的析构函数"><a href="#6-4-Bitmap的析构函数" class="headerlink" title="6.4 Bitmap的析构函数"></a>6.4 Bitmap的析构函数</h3><p>其实只要析构头地址就可以了…这里我写错了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_destroy</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = lbs_bitmap-&gt;bit_num; i == <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="built_in">free</span>(lbs_bitmap-&gt;bits + i)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="6-5-Bitmap设置位1"><a href="#6-5-Bitmap设置位1" class="headerlink" title="6.5 Bitmap设置位1"></a>6.5 Bitmap设置位1</h3><ul>
<li>找到pos是在第几个字节</li>
<li>找到pos是在该字节的哪个位</li>
<li>定义一个<code>mask</code>字节，将pos位设置为1</li>
<li>进行<strong>或</strong>运算</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_setbit</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_index = pos / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> bit_index = pos % <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_mask = (<span class="number">1</span> &lt;&lt; (<span class="number">8</span>-bit_index<span class="number">-1</span>));</span><br><span class="line">  lbs_bitmap-&gt;bits[byte_index] |= byte_mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="6-5-Bitmap设置位0"><a href="#6-5-Bitmap设置位0" class="headerlink" title="6.5 Bitmap设置位0"></a>6.5 Bitmap设置位0</h3><ul>
<li>找到pos是在第几个字节</li>
<li>找到pos是在该字节的哪个位</li>
<li>定义一个<code>mask</code>字节，将pos位设置为0</li>
<li>进行<strong>与</strong>运算</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_unsetbit</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_index = pos / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> bit_index = pos % <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_mask = ~(<span class="number">1</span> &lt;&lt; (<span class="number">8</span>-bit_index<span class="number">-1</span>));</span><br><span class="line">  lbs_bitmap-&gt;bits[byte_index] &amp;= byte_mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="6-5-Bitmap某位是否设置"><a href="#6-5-Bitmap某位是否设置" class="headerlink" title="6.5 Bitmap某位是否设置"></a>6.5 Bitmap某位是否设置</h3><ul>
<li>找到pos是在第几个字节</li>
<li>找到pos是在该字节的哪个位</li>
<li>定义一个<code>mask</code>字节，将pos位设置为1</li>
<li>进行<strong>与</strong>运算</li>
<li>判断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_bitmap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_bitmap_isset</span><span class="params">(<span class="keyword">lbs_bitmap_t</span> *lbs_bitmap, <span class="keyword">uint32_t</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_index = pos / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> bit_index = pos % <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> byte_mask = (<span class="number">1</span> &lt;&lt; (<span class="number">8</span>-bit_index));</span><br><span class="line">  lbs_bitmap-&gt;bits[byte_index] &amp;= byte_mask;</span><br><span class="line">  <span class="keyword">if</span> (lbs_bitmap-&gt;bits[byte_index] == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>    </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终止lbs_bitmap.cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="7-堆数据结构"><a href="#7-堆数据结构" class="headerlink" title="7.堆数据结构"></a>7.堆数据结构</h2><h3 id="7-1-堆的原理"><a href="#7-1-堆的原理" class="headerlink" title="7.1 堆的原理"></a>7.1 堆的原理</h3><p><strong>什么是堆:</strong></p>
<p>堆是满足下列性质的数据序列{r1, r2 , …,rn }<br>$$<br>\left{ \begin{array}{ll}<br>r_{2i} \ge r_i &amp;\<br>r_{2i+1}\ge r_i&amp;<br>\end{array} \right.(Min Heap)<br>$$<br>或者<br>$$<br>\left{ \begin{array}{ll}<br>r_{2i} \le r_i &amp;\<br>r_{2i+1}\le r_i&amp;<br>\end{array} \right.(Max Heap)<br>$$<br>当一个序列满足这种性质的时候，我们就可以在逻辑上认为它长这样，这样从上到下它就成为了一个堆的形状，可以看到每一个节点的左孩子节点和右孩子节点都要比它的父节点的数值更大，因此这是一个小顶堆:</p>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |</p>
<p>​                                                97</p>
<p><strong>堆的性质</strong></p>
<p>这个时候如果我们想要获得它的最大的元素只需要取得它的有元素即可。</p>
<p>在这里可以看到：</p>
<ul>
<li>对于一个索引是<code>i</code>的父节点(parent)，其左孩子(left child)索引为 <code>2i+1</code></li>
<li>对于一个索引是<code>i</code>的父节点(parent)，其右孩子(left child)索引为 <code>2i+2</code></li>
<li>对于一个索引是<code>i</code>的子节点，它的父节点的索引是 <code>(i - 1) / 2</code></li>
</ul>
<p>关于堆的操作我们在下文中讲。</p>
<h3 id="7-2堆的结构设计"><a href="#7-2堆的结构设计" class="headerlink" title="7.2堆的结构设计"></a>7.2堆的结构设计</h3><p>首先设计每一个堆的节点heapnode，存储以下的信息</p>
<ul>
<li>该节点距离目标点的距离</li>
<li>该节点是否为1个格子，1为是格子，0非格子</li>
<li>该<code>cell</code>的id号</li>
<li>存储一个车辆的节点信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_nnheap.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_heapnode_s</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> distance;</span><br><span class="line">        <span class="keyword">uint8_t</span> is_grid; <span class="comment">// 1是网格 0是移动对象</span></span><br><span class="line">        <span class="keyword">int</span> cell_id;</span><br><span class="line">        <span class="keyword">lbs_mov_node_t</span> *node;</span><br><span class="line">&#125; <span class="keyword">lbs_heapnode_t</span>;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<p>在定义heapnode结构以后，可以利用heapnode来定义heap结构</p>
<ul>
<li>包含它的已经被占用的容量<code>size</code>(开始定义一个数组有很多是空的)</li>
<li>它的容量<code>capacity</code></li>
<li>存储heapnode数据的头地址<code>heap_nodes</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lbs_nnheap_s</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> size;</span><br><span class="line">        <span class="keyword">uint32_t</span> capacity;</span><br><span class="line">        <span class="keyword">lbs_heapnode_t</span> * heap_nodes;</span><br><span class="line">&#125; <span class="keyword">lbs_nnheap_t</span>;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<p>声明堆的方法，包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.h</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_init</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap)</span></span>;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_destroy</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap)</span></span>;</span><br><span class="line"><span class="comment">//插入一个heapnode到堆</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_insert</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap, <span class="keyword">lbs_mov_node_t</span>* lbs_mov_node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> cell_id, <span class="keyword">uint8_t</span> is_grid, <span class="keyword">double</span> distance)</span></span>;</span><br><span class="line"><span class="comment">//获取堆顶heapnode</span></span><br><span class="line"><span class="keyword">lbs_heapnode_t</span> *lbs_nnheap_top(<span class="keyword">lbs_nnheap_t</span> *lbs_nnheap);</span><br><span class="line"><span class="comment">//弹出堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lbs_nnheap_pop</span><span class="params">(<span class="keyword">lbs_nnheap_t</span> *lbs_nnheap)</span></span>;</span><br><span class="line"><span class="comment">//结束lbs_nnheap.h</span></span><br></pre></td></tr></table></figure>
<h3 id="7-3-堆的初始化"><a href="#7-3-堆的初始化" class="headerlink" title="7.3 堆的初始化"></a>7.3 堆的初始化</h3><p>在初始化堆的时候，我们并不知道堆里有多少个节点，所以我们仅仅给它10个<code>heapnode</code>的内存空间。当不够用时再重新分配内存。但刚开始的时候size是0是可以确定的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_nnheap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_init</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap)</span></span>&#123;</span><br><span class="line">  lbs_nnheap-&gt;size = <span class="number">0</span>;</span><br><span class="line">  lbs_nnheap-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">  lbs_nnheap-&gt;heap_nodes = (<span class="keyword">lbs_heapnode_t</span>* )<span class="built_in">calloc</span>(capacity, <span class="keyword">sizeof</span>(<span class="keyword">heap_node_t</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-堆的析构"><a href="#7-4-堆的析构" class="headerlink" title="7.4 堆的析构"></a>7.4 堆的析构</h3><p>这里的析构也知道析构头地址里就可以了，写复杂了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_destroy</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = lbs_nnheap-&gt;capacity; i == <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="built_in">free</span>(lbs_nnheap-&gt;heap_nodes + i)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-将一个heapnode插入堆"><a href="#7-5-将一个heapnode插入堆" class="headerlink" title="7.5 将一个heapnode插入堆"></a>7.5 将一个heapnode插入堆</h3><p>插入堆的算法相应复杂，值得一写。大体可以几个步骤，我们以下面这个堆为例，假设我们需要插入节点31</p>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |</p>
<p>​                                                97</p>
<ul>
<li>step1 将新插入的节点放在堆的末尾</li>
</ul>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |       |</p>
<p>​                                                97     <strong>31</strong></p>
<ul>
<li>step2  将插入的节点与父节点进行对比，也就是和50对比，比50小则互换位置，否则不动</li>
</ul>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    <strong>31</strong>       76    65     49</p>
<p>​                                                 |       |</p>
<p>​                                                97     <strong>50</strong></p>
<ul>
<li>step3 如此迭代，直到到达一个合适的位置结束</li>
</ul>
<p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            <strong>31</strong>          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    <strong>38</strong>       76    65     49</p>
<p>​                                                 |       |</p>
<p>​                                                97     50</p>
<p>下面是插入一个节点的代码实现。注意一下几点：</p>
<ul>
<li>在插入一个新节点的时候，如果超出了<code>nnheap</code>的<code>capacity</code>则需要使用<code>reaclloc</code>指令重新分配内存</li>
<li>这里我们是使用的孩子节点和父节点的数组的秩来进行比较大小和互换位置。</li>
<li>仔细思考秩+1，-1的区别，遍历到每一个节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_nnheap_insert</span><span class="params">(<span class="keyword">lbs_nnheap_t</span>* lbs_nnheap, <span class="keyword">lbs_mov_node_t</span>* lbs_mov_node,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> cell_id, <span class="keyword">uint8_t</span> is_grid, <span class="keyword">double</span> distance)</span></span>&#123;</span><br><span class="line">  <span class="comment">//新建一个heapnode</span></span><br><span class="line">  <span class="keyword">lbs_heapnode_t</span> new_heapnode;</span><br><span class="line">  new_heapnode.is_grid = is_grid;</span><br><span class="line">  new_heapnode.cell_id = cell_id;</span><br><span class="line">  new_heapnode.node = lbs_mov_node;</span><br><span class="line">  new_heapnode.distance = distance;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//在capacity已经被填满以后，重新分配内存。插入新节点</span></span><br><span class="line">  <span class="keyword">if</span> (lbs_nnheap-&gt;size == lbs_nnheap-&gt;capacity)&#123;</span><br><span class="line">    lbs_nnheap-&gt;heap_nodes = (<span class="keyword">lbs_heapnode_t</span>* )<span class="built_in">realloc</span>(lbs_nnheap-&gt;heap_nodes, <span class="number">2</span>* capacity*(<span class="keyword">sizeof</span>(<span class="keyword">heap_node_t</span>))); </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">int</span> new_node_index = size + <span class="number">1</span>;</span><br><span class="line">  lbs_nnheap-&gt;(heap_nodes + new_node_index) = new_heapnode;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//取出新插入的节点和其父节点的秩，以及一个中间节点</span></span><br><span class="line">  lbs_nnheap-&gt;size++;</span><br><span class="line">  <span class="keyword">int</span> child = lbs_nnheap-&gt;size;</span><br><span class="line">  <span class="keyword">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">lbs_heapnode_t</span> temp_heapnode;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//互换直至插入节点到达正确的位置</span></span><br><span class="line">  <span class="keyword">while</span> (parent_node-&gt;distance &gt; inserted_node-&gt;distance)&#123;</span><br><span class="line">    temp_heapnode = lbs_nnheap-&gt;heap_nodes[child];</span><br><span class="line">    lbs_nnheap-&gt;heap_nodes[child] = lbs_nnheap-&gt;heap_nodes[parent];</span><br><span class="line">    lbs_nnheap-&gt;heap_nodes[parent] = temp_heapnode;</span><br><span class="line">    parent = (parent - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="7-6-获取堆的头结点"><a href="#7-6-获取堆的头结点" class="headerlink" title="7.6 获取堆的头结点"></a>7.6 获取堆的头结点</h3><p>返回头地址即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.cpp</span></span><br><span class="line"><span class="keyword">lbs_heapnode_t</span> *lbs_nnheap_top(<span class="keyword">lbs_nnheap_t</span> *lbs_nnheap)&#123;</span><br><span class="line">  <span class="keyword">return</span> lbs_nnheap-&gt;heap_nodes</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="7-7-删除头结点"><a href="#7-7-删除头结点" class="headerlink" title="7.7 删除头结点"></a>7.7 删除头结点</h3><p>​                                                                  13</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |</p>
<p>​                                                97</p>
<p>删除头结点并没有看上去那么简单，首先我们去掉头结点，堆也就变成了下面这种结构(没有了头的堆不应该被称作堆)，所以我们需要通过以下几个步骤重新建堆：</p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<p>​                                                 |</p>
<p>​                                                97</p>
<ul>
<li>step1 将最后一个节点放在头结点上</li>
</ul>
<p>​                                                                  <strong>97</strong></p>
<p>​                                                             |            |</p>
<p>​                                                            38          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<ul>
<li>step2 将<strong>头结点</strong>与其<strong>子节点中较大的一个子节点</strong>比较大小，如果<strong>头结点</strong>大于该<strong>子节点</strong>则位置互换</li>
</ul>
<p>​                                                                  <strong>38</strong></p>
<p>​                                                             |            |</p>
<p>​                                                            <strong>97</strong>          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       76    65     49</p>
<ul>
<li>step3 如此往复，直到该头结点到达正确的位置结束</li>
</ul>
<p>​                                                                  38</p>
<p>​                                                             |            |</p>
<p>​                                                            <strong>76</strong>          27</p>
<p>​                                                      |         |      |       |</p>
<p>​                                                    50       <strong>97</strong>    65     49</p>
<p>下面是该过程的代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_nnheap.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lbs_nnheap_pop</span><span class="params">(<span class="keyword">lbs_nnheap_t</span> *lbs_nnheap)</span></span>&#123;</span><br><span class="line">  <span class="comment">//将头结点替换为最后一个节点，并释放最后一个节点的内存</span></span><br><span class="line">  lbs_nnheap-&gt;heap_nodes[<span class="number">0</span>] = lbs_nnheap-&gt;heap_nodes[lbs_nnheap-&gt;size];</span><br><span class="line">  lbs_nnheap-&gt;size--;</span><br><span class="line">  <span class="comment">//free(lbs_nnheap-&gt;heap_nodes + size);数组的空间是连续的，不能一次free掉，链表的内存分配是不连续的所以必须借助一个循环体，不停地释放</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//计算父节点和左右子节点的秩</span></span><br><span class="line">  <span class="keyword">int</span> parent = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> l_child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> r_child = <span class="number">2</span> * parent + <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((l_child &lt; lbs_nnheap-&gt;size) || (r_child &lt; lbs_nnheap-&gt;size)&#123;     </span><br><span class="line">    <span class="comment">//heapify</span></span><br><span class="line">    <span class="keyword">while</span>((lbs_nnheap-&gt;heap_nodes[parent].distance &lt; lbs_nnheap-&gt;heap_nodes[l_child].distance) || (lbs_nnheap-&gt;heap_nodes[parent].distance &lt; lbs_nnheap-&gt;heap_nodes[r_child].distance))&#123;</span><br><span class="line">      <span class="keyword">lbs_heapnode_t</span> temp_heapnode;</span><br><span class="line">      <span class="comment">//当右子节点比较大时</span></span><br><span class="line">      <span class="keyword">if</span> (lbs_nnheap-&gt;heap_nodes[l_child].distance &lt; lbs_nnheap-&gt;heap_nodes[r_child].distance)&#123;</span><br><span class="line">        temp_heapnode = lbs_nnheap-&gt;heap_nodes[r_child];</span><br><span class="line">        lbs_nnheap-&gt;heap_nodes[r_child] = lbs_nnheap-&gt;heap_nodes[parent];</span><br><span class="line">        lbs_nnheap-&gt;heap_nodes[parent] = temp_heapnode;</span><br><span class="line">        parent = r_child;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//当左子节点比较大时  </span></span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        temp_heapnode = lbs_nnheap-&gt;heap_nodes[l_child];</span><br><span class="line">        lbs_nnheap-&gt;heap_nodes[l_child] = lbs_nnheap-&gt;heap_nodes[parent];</span><br><span class="line">        lbs_nnheap-&gt;heap_nodes[parent] = temp_heapnode;</span><br><span class="line">        parent = l_child; </span><br><span class="line">        &#125;</span><br><span class="line">      l_child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">      r_child = <span class="number">2</span> * parent + <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;      </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终止lbs_nnheap.cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="8-实现knn-query"><a href="#8-实现knn-query" class="headerlink" title="8. 实现knn_query"></a>8. 实现knn_query</h2><h3 id="8-1算法原理"><a href="#8-1算法原理" class="headerlink" title="8.1算法原理"></a>8.1算法原理</h3><p>knn_query，就是选择距离最近的k辆车，那么我们的思路是一个什么样的呢，最简单的方法当然是对每一辆车进行遍历，着这样的速度太慢，于是我们可以<strong>借助网格</strong>对<strong>堆数据结构</strong>进行剪枝的处理。</p>
<p>处理之前，因为我们要借助网格剪枝，所以首先需要了解一个MinDist的概念。</p>
<p><strong>MinDist等于点P与O的边界上任意点之间的最小距离。若P在O内，则距离为0</strong></p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 11-12-37屏幕截图.png" alt="2018-08-04 11-12-37屏幕截图"></p>
<p><strong>step1</strong> 在了解这个概念以后，我们就可以最近邻算法的书写了，假设我们的起始地点为q，q点位于Cell01(C0)处</p>
<ul>
<li>我们首先使用C0建一个堆，此时距离为0，此时的堆如下：</li>
</ul>
<p>​                                                                           C0</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 11-15-06屏幕截图.png" alt="2018-08-04 11-15-06屏幕截图"></p>
<p><strong>step2</strong> 弹出堆中的头元素(这里就是C0)，如果是个格子，则遍历C0中的每一辆车插入到堆当中；如果头结点是辆车，则说明我们已经找到最近的车了。此处C0是一个格子，我们删去C0，并将C0当中的两辆车a和b插入到堆当中，此处的堆就成为下面这个结构：</p>
<p>​                                                                           a</p>
<p>​                                                                       |</p>
<p>​                                                                       b</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 21-29-14屏幕截图.png" alt="2018-08-04 21-29-14屏幕截图"></p>
<p><strong>step3</strong> 随后检测C0周围的每一个格子，总共有八个我们将他们命名为C11－C18，计算他们的MinDist，插入堆当中，并将相应的Bitmap位设置为1，下一次再遇到这这些格子就可以不必检查了</p>
<p><strong>注意</strong>：此处由于是第一个格子C0，其周围的8个格子均未被检测，所以可以直接插入，如果在后面需要先在Bitmap中查看是否为1再决定是否插入。</p>
<p>插入后的堆如下图所示:</p>
<p>​                                                                           C12</p>
<p>​                                                                      |            |</p>
<p>​                                                                      a          C14</p>
<p>​                                                                |        |     |        |</p>
<p>​                                                            C15   C11   C13      b</p>
<p>​                                                        |       |     |</p>
<p>​                                                   C17    C16   C18</p>
<p><img src="/2018/08/05/基于LBS的出租车检索内核实现/2018-08-04 21-29-29屏幕截图.png" alt="2018-08-04 21-29-29屏幕截图"></p>
<p><strong>step4</strong> 重复step2，指导弹出的是一个车辆就是我们想要找到的目标车辆。   </p>
<h3 id="8-2-定义全局变量和函数"><a href="#8-2-定义全局变量和函数" class="headerlink" title="8.2 定义全局变量和函数"></a>8.2 定义全局变量和函数</h3><p>这里主要完成了2个工作</p>
<ul>
<li>定义了多个宏</li>
<li>定义了根据经纬度计算距离的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lbs_distance.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SERVER_GRID_LBS_DISTANCE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_GRID_LBS_DISTANCE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159265</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEG2RAD(degree) (degree * PI) / 180.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EARTH_RADIUS 6378.137</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">lbs_distance</span><span class="params">(<span class="keyword">double</span> lon1, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lon2, <span class="keyword">double</span> lat2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> rad_lat1 = DEG2RAD(lat1);</span><br><span class="line">  <span class="keyword">double</span> rad_lat2 = DEG2RAD(lat2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> a = rad_lat1 - rad_lat2;</span><br><span class="line">  <span class="keyword">double</span> b = DEG2RAD(lon1) - DEG2RAD(lon2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> s = <span class="number">2</span> * <span class="built_in">asin</span>(<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">sin</span>(a / <span class="number">2</span>), <span class="number">2</span>) +</span><br><span class="line">                           <span class="built_in">cos</span>(rad_lat1) * <span class="built_in">cos</span>(rad_lat2) * <span class="built_in">pow</span>(<span class="built_in">sin</span>(b / <span class="number">2</span>), <span class="number">2</span>)));</span><br><span class="line">  s = s * EARTH_RADIUS;</span><br><span class="line">  <span class="keyword">return</span> s * <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-编写MinDist函数"><a href="#8-3-编写MinDist函数" class="headerlink" title="8.3 编写MinDist函数"></a>8.3 编写MinDist函数</h3><p>MinDist的大小根据格子所在源格子的位置有所不同，共有九种情况，以下做了分别的编写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见上，lbs_distance.h</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dist_min</span><span class="params">(<span class="keyword">lbs_grid_t</span>* lbs_grid, <span class="keyword">double</span> src_lon, <span class="keyword">double</span> src_lat, <span class="keyword">int</span> dis_cell_id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> grid_distance;</span><br><span class="line">  <span class="keyword">double</span> des_lon;</span><br><span class="line">  <span class="keyword">double</span> des_lat;</span><br><span class="line">  <span class="keyword">int</span> src_cell_row = lbs_grid_cell_row(lbs_grid, src_lat)</span><br><span class="line">  <span class="keyword">int</span> src_cell_col = lbs_grid_cell_col(lbs_grid, src_lon)</span><br><span class="line">  lbs_grid_cell_row_col(lbs_grid, dis_cell_id, &amp;(<span class="keyword">int</span> des_cell_row), &amp;(<span class="keyword">int</span> des_cell_col));</span><br><span class="line">  <span class="comment">//左上的格子</span></span><br><span class="line">  <span class="keyword">if</span> (des_cell_row &gt; src_cell_row) &amp; (des_cell_col &lt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col + <span class="number">1</span>) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//直上的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row &gt; src_cell_row) &amp; (des_cell_col == src_cell_col)&#123;</span><br><span class="line">    des_lon = src_lon;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//右上的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row &gt; src_cell_row) &amp; (des_cell_col &gt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row) * lbs_grid-&gt;cell_height; </span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//直左的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row == src_cell_row) &amp; (des_cell_col &lt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col + <span class="number">1</span>) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = src_lat;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//直右的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row == src_cell_row) &amp; (des_cell_col &gt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = src_lat;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);    </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//本身的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row == src_cell_row) &amp; (des_cell_col == src_cell_col)&#123;</span><br><span class="line">    grid_distance = <span class="number">0</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//左下的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row &lt; src_cell_row) &amp; (des_cell_col &lt; src_cell_col)&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col + <span class="number">1</span>) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row + <span class="number">1</span>) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);  </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//直下的格子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (des_cell_row &lt; src_cell_row) &amp; (des_cell_col == src_cell_col)&#123;</span><br><span class="line">    des_lon = src_lon;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row + <span class="number">1</span>) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);   </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//右下的格子</span></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    des_lon = LBS_LON_MIN + (des_cell_col) * lbs_grid-&gt;cell_width;</span><br><span class="line">    des_lat = LBS_LAT_MIN + (des_cell_row + <span class="number">1</span>) * lbs_grid-&gt;cell_height;</span><br><span class="line">    grid_distance = lbs_distance(src_lon, src_lat, des_lon, des_lat);  </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> grid_distance</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束lbs_distance.h</span></span><br></pre></td></tr></table></figure>
<h3 id="8-4-实现knn-query"><a href="#8-4-实现knn-query" class="headerlink" title="8.4 实现knn_query"></a>8.4 实现knn_query</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//见第五部分range_query函数,lbs_index.cpp</span></span><br><span class="line"><span class="comment">// NN查询接口[查询离lon,lat最近的出租车]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lbs_grid_index_nn_query</span><span class="params">(<span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">lbs_res_node_t</span>* out)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取第src车所在的位置和网格信息</span></span><br><span class="line">  <span class="keyword">double</span> src_lon = lon;</span><br><span class="line">  <span class="keyword">double</span> src_lat = lat;</span><br><span class="line">  <span class="keyword">int</span> src_cell_row = lbs_grid_cell_row(&amp;(lbs_grid), src_lat);</span><br><span class="line">  <span class="keyword">int</span> src_cell_col = lbs_grid_cell_col(&amp;(lbs_grid), src_lon);</span><br><span class="line">  <span class="keyword">int</span> src_cell_id = lbs_grid_cell_id(&amp;(lbs_grid), src_cell_row, src_cell_col);</span><br><span class="line">  <span class="comment">//初始化bitmap，并将src车所在的cell0记录在bitmap里</span></span><br><span class="line">  <span class="keyword">lbs_bitmap_t</span> lbs_bitmap;</span><br><span class="line">  <span class="keyword">int</span> ret = lbs_bitmap_init(&amp;(lbs_bitmap), (lbs_grid.col_num*lbs_grid.row_num));</span><br><span class="line">  ret = lbs_bitmap_setbit(lbs_bitmap, src_cell_id);</span><br><span class="line">  <span class="comment">//利用C0构建最小堆</span></span><br><span class="line">  lbs_nnheap_init lbs_nnheap;</span><br><span class="line">  ret = lbs_nnheap(&amp;(lbs_nnheap));</span><br><span class="line">  ret = lbs_nnheap_insert(&amp;(lbs_nnheap), )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">lbs_mov_node_t</span> lbs_mov_node;</span><br><span class="line">  <span class="keyword">int</span> is_grid = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">double</span> distance = Dist_min(&amp;(lbs_grid), src_lon, src_lat, src_cell_id);</span><br><span class="line">  ret = lbs_nnheap_insert(&amp;(lbs_nnheap), &amp;(lbs_mov_node), src_cell_id, is_grid, distance);</span><br><span class="line">  <span class="comment">//获取头结点</span></span><br><span class="line">  <span class="keyword">lbs_heapnode_t</span>* nnheap_top = lbs_nnheap_top(lbs_nnheap);</span><br><span class="line">  <span class="keyword">int</span> temp_cell_id = src_cell_id;</span><br><span class="line">  <span class="keyword">while</span>(nnheap_top-&gt;is_grid == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//pop掉为grid的头结点</span></span><br><span class="line">    lbs_nnheap_pop(&amp;(lbs_nnheap));</span><br><span class="line">    <span class="comment">//找到该cell里的所有车辆信息，并且插入到heap</span></span><br><span class="line">    <span class="keyword">lbs_mov_node_t</span>* headnode = (<span class="keyword">lbs_mov_node_t</span>* )&amp;(lbs_grid-&gt;cell[temp_cell_id].dammy_node.<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">lbs_mov_node_t</span>* currnode = (<span class="keyword">lbs_mov_node_t</span>* )&amp;(lbs_grid-&gt;cell[temp_cell_id].dammy_node.<span class="built_in">queue</span>.next);</span><br><span class="line">    <span class="keyword">while</span>(headnode != curnode)&#123;</span><br><span class="line">      distance = lbs_distance(src_lon, src_lat, currnode-&gt;lon, currnode-&gt;lat);</span><br><span class="line">      ret = lbs_nnheap_insert(&amp;(lbs_nnheap), currnode, src_cell_id, is_grid = <span class="number">1</span>, distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出目前格子周围的未被检查的格子的cell_id，存入surrounding_id_arr中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">-1</span>; i == <span class="number">1</span>; i ++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">-1</span>; j == <span class="number">1</span>; j ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> new_cell_id = src_cell_id + (i * LBS_COL_NUM) + j;</span><br><span class="line">        ret = lbs_bitmap_isset(&amp;(lbs_bitmap), new_cell_id);</span><br><span class="line">        <span class="keyword">if</span> ret == <span class="number">0</span>&#123;</span><br><span class="line">          distance = Dist_min(&amp;(lbs_grid), src_lon, src_lat, new_cell_id);</span><br><span class="line">          ret = lbs_nnheap_insert(&amp;(lbs_nnheap), &amp;(lbs_mov_node), new_cell_id, is_grid = <span class="number">1</span>, distance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">continue</span>    </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出headnode</span></span><br><span class="line">    nnheap_top = lbs_nnheap_top(lbs_nnheap);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个out就是list of 符合条件的车</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束lbs_index.cpp</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Data-Structure/" rel="tag"># Data Structure</a>
          
            <a href="/tags/C-C/" rel="tag"># C++/C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/05/Liunx服务器基本操作/" rel="next" title="Linux服务器基本操作">
                <i class="fa fa-chevron-left"></i> Linux服务器基本操作
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/06/预习作业2-快速排序算法/" rel="prev" title="预习作业2--快速排序算法">
                预习作业2--快速排序算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhaocheng Du</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基于LBS的打车APP开发"><span class="nav-number">1.</span> <span class="nav-text">基于LBS的打车APP开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-基本知识"><span class="nav-number">1.1.</span> <span class="nav-text">1.基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-索引相关知识"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 索引相关知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-C中的位操作"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 C中的位操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-数据存储相关知识"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 数据存储相关知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-宏的相关定义"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 宏的相关定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-双向列表数据结构"><span class="nav-number">1.2.</span> <span class="nav-text">2.双向列表数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-双向链表结构设计"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 双向链表结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-车辆点结构设计"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 车辆点结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-链表的相关操作"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 链表的相关操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-哈希表数据结构"><span class="nav-number">1.3.</span> <span class="nav-text">3.哈希表数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-算法原理"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-哈希表节点结构设计"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 哈希表节点结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-哈希表结构设计"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 哈希表结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-哈希表的初始化"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 哈希表的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-哈希表析构函数"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 哈希表析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-设置一个哈希节点并插入哈希表"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6 设置一个哈希节点并插入哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-获取哈希节点信息"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.7 获取哈希节点信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-二维数组的网格降维处理"><span class="nav-number">1.4.</span> <span class="nav-text">4. 二维数组的网格降维处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-网格结构设计及其属性"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 网格结构设计及其属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2网格数据结构初始化"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2网格数据结构初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-网络数据结构析构"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 网络数据结构析构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-在屏幕发生变化时更新节点信息"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 在屏幕发生变化时更新节点信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-获取网格属性"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 获取网格属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-实现网格范围索引-range-query"><span class="nav-number">1.5.</span> <span class="nav-text">5. 实现网格范围索引(range_query)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1进行网格范围索引的最终结构"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1进行网格范围索引的最终结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-存储节点结构设计"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 存储节点结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-定义索引方法"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3 定义索引方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-初始化网格索引"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4 初始化网格索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-定义网格更新接口"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.5 定义网格更新接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-实现range-query函数"><span class="nav-number">1.5.6.</span> <span class="nav-text">5.6 实现range_query函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Bitmap数据结构"><span class="nav-number">1.6.</span> <span class="nav-text">6. Bitmap数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Bitmap算法原理"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1 Bitmap算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Bitmap结构设计"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2 Bitmap结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3Bitmap的初始化"><span class="nav-number">1.6.3.</span> <span class="nav-text">6.3Bitmap的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-Bitmap的析构函数"><span class="nav-number">1.6.4.</span> <span class="nav-text">6.4 Bitmap的析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-Bitmap设置位1"><span class="nav-number">1.6.5.</span> <span class="nav-text">6.5 Bitmap设置位1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-Bitmap设置位0"><span class="nav-number">1.6.6.</span> <span class="nav-text">6.5 Bitmap设置位0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-Bitmap某位是否设置"><span class="nav-number">1.6.7.</span> <span class="nav-text">6.5 Bitmap某位是否设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-堆数据结构"><span class="nav-number">1.7.</span> <span class="nav-text">7.堆数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-堆的原理"><span class="nav-number">1.7.1.</span> <span class="nav-text">7.1 堆的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2堆的结构设计"><span class="nav-number">1.7.2.</span> <span class="nav-text">7.2堆的结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-堆的初始化"><span class="nav-number">1.7.3.</span> <span class="nav-text">7.3 堆的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-堆的析构"><span class="nav-number">1.7.4.</span> <span class="nav-text">7.4 堆的析构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-将一个heapnode插入堆"><span class="nav-number">1.7.5.</span> <span class="nav-text">7.5 将一个heapnode插入堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-获取堆的头结点"><span class="nav-number">1.7.6.</span> <span class="nav-text">7.6 获取堆的头结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-删除头结点"><span class="nav-number">1.7.7.</span> <span class="nav-text">7.7 删除头结点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-实现knn-query"><span class="nav-number">1.8.</span> <span class="nav-text">8. 实现knn_query</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1算法原理"><span class="nav-number">1.8.1.</span> <span class="nav-text">8.1算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-定义全局变量和函数"><span class="nav-number">1.8.2.</span> <span class="nav-text">8.2 定义全局变量和函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-编写MinDist函数"><span class="nav-number">1.8.3.</span> <span class="nav-text">8.3 编写MinDist函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-实现knn-query"><span class="nav-number">1.8.4.</span> <span class="nav-text">8.4 实现knn_query</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhaocheng Du</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
